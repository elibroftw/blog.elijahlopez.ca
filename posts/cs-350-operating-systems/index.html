<!doctype html><html lang=en data-theme=dark><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>CS 350 Operating Systems - ELL Blog</title>
<meta name=description content="Course website Past midterms Table of Contents Concepts Course Topics Assignment Helpers CS 350 CLI How to add to PATH Finding stuff in the kernal code Setting up on a new Machine Building the kernel Running the kernel on a simulator Debugging Working locally Submitting Assignments Readelf Processes Abstractions Sections Creating processes Pipes Implementing Processes Context Switch Threads POSIX Thread API Limitations of Kernel Threads Go Language Routines Implementing threads in OS/161 Concurrency Sequential Consistency x86 Consistency x86 Atomicity Peterson&rsquo;s Solution Mutexes Condition Variables Semaphores Synchronization Motivation Ordering requirements MIPS Spinlocks Atomics C11 Cache Coherence Multicore Caches 3-State Coherence Protocol (MSI) Core and Bus Actions Multithreaded Design Deadlocks Solving Deadlocks Wait Channels System Calls Privilege Modes Mode Transitions System Call Handling Hardware Handling in MIPS R3000 MIPS Review Application Binary Interface Execution Contexts Preemption Process Context Switch Virtual Memory Hardware Sharing Memory Issues Virtual Memory Goals Virtual Memory Advantages Load-time Linking base + bound register Segmentation Fragmentation Paging MMUs Hardware Managed MMU TLB OS Software Managed MMU Virtual Memory OS Increasing Virtual Memory by Paging Page Buffering Page Allocation Thrashing Scheduling CPU Scheduling First Come First Served Bursts of Computation and I/O Shortest Job First Round Robin Time Quantum Priority Scheduling Multilevel Feedback Queue Priority Donation Borrowed Virtual Time Scheduler Sleep / Wakeup Real-time Threads I/O Memory and I/O buses Memory Types Device Communication Driver Architecture Disks (I/O Subtopic) Disk Positioning System Seeking Sectors Disk Interface Buses SCSI Requests SCSI Exceptions Disk Performance Disk Scheduling Flash Memory Filesystem Files: name bytes on disk Mappings Intuitions Common Patterns DOS FS Indexed files Multi-level indexed files Directories Hard and soft links Fast File System (FFS) Log-Structured File System Metadata Synchronously The Slab Allocator Object Caching Questions The Fast File System Concepts Operating Systems Distributed Systems Networking Internet of Things Computer Architecture Embedded Systems Database Systems Systems and Machine Learning Course Topics Threads & Processes Concurrency & Synchronization Scheduling Virtual Memory I/O Disks, File systems, Network file systems Protection & Security Unix referenced as an example Assignment Helpers CS 350 CLI File hierarchy"><link rel=icon type=image/x-icon href=https://blog.elijahlopez.ca/favicon.ico><link rel=apple-touch-icon-precomposed href=https://blog.elijahlopez.ca/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=https://blog.elijahlopez.ca/css/style.min.ccf2576b8f635114a857ab1559f7d6e315740f00d29b3a8b9572181998dd1a72.css integrity="sha256-zPJXa49jURSoV6sVWffW4xV0DwDSmzqLlXIYGZjdGnI="><script src=https://blog.elijahlopez.ca/js/script.min.74bf1a3fcf1af396efa4acf3e660e876b61a2153ab9cbe1893ac24ea6d4f94ee.js type=text/javascript integrity="sha256-dL8aP88a85bvpKzz5mDodrYaIVOrnL4Yk6wk6m1PlO4="></script><meta property="og:title" content="CS 350 Operating Systems"><meta property="og:description" content="Course website Past midterms Table of Contents Concepts Course Topics Assignment Helpers CS 350 CLI How to add to PATH Finding stuff in the kernal code Setting up on a new Machine Building the kernel Running the kernel on a simulator Debugging Working locally Submitting Assignments Readelf Processes Abstractions Sections Creating processes Pipes Implementing Processes Context Switch Threads POSIX Thread API Limitations of Kernel Threads Go Language Routines Implementing threads in OS/161 Concurrency Sequential Consistency x86 Consistency x86 Atomicity Peterson&rsquo;s Solution Mutexes Condition Variables Semaphores Synchronization Motivation Ordering requirements MIPS Spinlocks Atomics C11 Cache Coherence Multicore Caches 3-State Coherence Protocol (MSI) Core and Bus Actions Multithreaded Design Deadlocks Solving Deadlocks Wait Channels System Calls Privilege Modes Mode Transitions System Call Handling Hardware Handling in MIPS R3000 MIPS Review Application Binary Interface Execution Contexts Preemption Process Context Switch Virtual Memory Hardware Sharing Memory Issues Virtual Memory Goals Virtual Memory Advantages Load-time Linking base + bound register Segmentation Fragmentation Paging MMUs Hardware Managed MMU TLB OS Software Managed MMU Virtual Memory OS Increasing Virtual Memory by Paging Page Buffering Page Allocation Thrashing Scheduling CPU Scheduling First Come First Served Bursts of Computation and I/O Shortest Job First Round Robin Time Quantum Priority Scheduling Multilevel Feedback Queue Priority Donation Borrowed Virtual Time Scheduler Sleep / Wakeup Real-time Threads I/O Memory and I/O buses Memory Types Device Communication Driver Architecture Disks (I/O Subtopic) Disk Positioning System Seeking Sectors Disk Interface Buses SCSI Requests SCSI Exceptions Disk Performance Disk Scheduling Flash Memory Filesystem Files: name bytes on disk Mappings Intuitions Common Patterns DOS FS Indexed files Multi-level indexed files Directories Hard and soft links Fast File System (FFS) Log-Structured File System Metadata Synchronously The Slab Allocator Object Caching Questions The Fast File System Concepts Operating Systems Distributed Systems Networking Internet of Things Computer Architecture Embedded Systems Database Systems Systems and Machine Learning Course Topics Threads & Processes Concurrency & Synchronization Scheduling Virtual Memory I/O Disks, File systems, Network file systems Protection & Security Unix referenced as an example Assignment Helpers CS 350 CLI File hierarchy"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.elijahlopez.ca/posts/cs-350-operating-systems/"><meta property="og:image" content="https://blog.elijahlopez.ca/images"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-10T14:56:10-05:00"><meta property="article:modified_time" content="2023-01-10T14:56:10-05:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.elijahlopez.ca/images"><meta name=twitter:title content="CS 350 Operating Systems"><meta name=twitter:description content="Course website Past midterms Table of Contents Concepts Course Topics Assignment Helpers CS 350 CLI How to add to PATH Finding stuff in the kernal code Setting up on a new Machine Building the kernel Running the kernel on a simulator Debugging Working locally Submitting Assignments Readelf Processes Abstractions Sections Creating processes Pipes Implementing Processes Context Switch Threads POSIX Thread API Limitations of Kernel Threads Go Language Routines Implementing threads in OS/161 Concurrency Sequential Consistency x86 Consistency x86 Atomicity Peterson&rsquo;s Solution Mutexes Condition Variables Semaphores Synchronization Motivation Ordering requirements MIPS Spinlocks Atomics C11 Cache Coherence Multicore Caches 3-State Coherence Protocol (MSI) Core and Bus Actions Multithreaded Design Deadlocks Solving Deadlocks Wait Channels System Calls Privilege Modes Mode Transitions System Call Handling Hardware Handling in MIPS R3000 MIPS Review Application Binary Interface Execution Contexts Preemption Process Context Switch Virtual Memory Hardware Sharing Memory Issues Virtual Memory Goals Virtual Memory Advantages Load-time Linking base + bound register Segmentation Fragmentation Paging MMUs Hardware Managed MMU TLB OS Software Managed MMU Virtual Memory OS Increasing Virtual Memory by Paging Page Buffering Page Allocation Thrashing Scheduling CPU Scheduling First Come First Served Bursts of Computation and I/O Shortest Job First Round Robin Time Quantum Priority Scheduling Multilevel Feedback Queue Priority Donation Borrowed Virtual Time Scheduler Sleep / Wakeup Real-time Threads I/O Memory and I/O buses Memory Types Device Communication Driver Architecture Disks (I/O Subtopic) Disk Positioning System Seeking Sectors Disk Interface Buses SCSI Requests SCSI Exceptions Disk Performance Disk Scheduling Flash Memory Filesystem Files: name bytes on disk Mappings Intuitions Common Patterns DOS FS Indexed files Multi-level indexed files Directories Hard and soft links Fast File System (FFS) Log-Structured File System Metadata Synchronously The Slab Allocator Object Caching Questions The Fast File System Concepts Operating Systems Distributed Systems Networking Internet of Things Computer Architecture Embedded Systems Database Systems Systems and Machine Learning Course Topics Threads & Processes Concurrency & Synchronization Scheduling Virtual Memory I/O Disks, File systems, Network file systems Protection & Security Unix referenced as an example Assignment Helpers CS 350 CLI File hierarchy"></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header class=common-header><div class=header-top><h1 class=site-title><a href=/>ELL Blog</a></h1><ul class=social-icons><li><a href=/index.xml title=Rss rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" data-icon="rss" data-prefix="fas" focusable="false" role="img" viewBox="0 0 496 512"><path fill="currentcolor" fill="currentcolor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg></span></a></li><li><a href=https://elijahlopez.ca title=Website rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M352 256C352 278.2 350.8 299.6 348.7 320H163.3C161.2 299.6 159.1 278.2 159.1 256S161.2 212.4 163.3 192H348.7C350.8 212.4 352 233.8 352 256zm151.9-64C509.2 212.5 512 233.9 512 256S509.2 299.5 503.9 320H380.8C382.9 299.4 384 277.1 384 256 384 234 382.9 212.6 380.8 192H503.9zm-10.5-32H376.7c-10-63.86-29.8-117.38-55.3-151.558C399.8 29.09 463.4 85.94 493.4 160zm-149.1.0H167.7C173.8 123.6 183.2 91.38 194.7 65.35c10.5-23.61 22.2-40.74 33.5-51.54C239.4 3.178 248.7.0 256 0s16.6 3.178 27.8 13.81c11.3 10.8 23 27.93 33.5 51.54 11.5 26.03 20.9 58.25 27 94.65h0zM18.61 160C48.59 85.94 112.2 29.09 190.6 8.442 165.1 42.62 145.3 96.14 135.3 160H18.61zM131.2 192C129.1 212.6 127.1 234 127.1 256 127.1 277.1 129.1 299.4 131.2 320H8.065C2.8 299.5.0 278.1.0 256c0-22.1 2.8-43.5 8.065-64H131.2zm63.5 254.6c-11.5-26-20.9-58.2-27-94.6H344.3C338.2 388.4 328.8 420.6 317.3 446.6c-10.5 23.7-22.2 40.8-33.5 51.6-11.2 10.6-20.5 13.8-28.7 13.8C248.7 512 239.4 508.8 228.2 498.2c-11.3-10.8-23-27.9-33.5-51.6h0zM190.6 503.6C112.2 482.9 48.59 426.1 18.61 352H135.3c10 63.9 29.8 117.4 55.3 151.6v0zm130.8.0C346.9 469.4 366.7 415.9 376.7 352H493.4c-30 74.1-93.6 130.9-172 151.6v0z"/></svg></span></a></li><li><a href=https://github.com/elibroftw title=Github rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a></li><li><a href=https://twitter.com/elibroftw title=Twitter rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span></a></li><li><a href=https://www.youtube.com/c/elibroftw title=Youtube rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentcolor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78.0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"/></svg></span></a></li><li><a href=mailto:elijahllopezz@gmail.com title=Email rel=me><span class=inline-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M464 64H48C21.49 64 0 85.49.0 112v288c0 26.51 21.49 48 48 48h416c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 4e2V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V4e2H48z"/></svg></span></a></li></ul></div><nav><a href=https://blog.elijahlopez.ca/ title=Home>Home</a>
<a href=https://blog.elijahlopez.ca/posts/ title=Archive>Archive</a>
<a href=https://blog.elijahlopez.ca/tags/ title=Tags>Tags</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">CS 350 Operating Systems</h1></header></div><div class="content e-content"><ul><li><a href=https://student.cs.uwaterloo.ca/~cs350/W23/reading.shtml>Course website</a></li><li><a href=https://student.cs.uwaterloo.ca/~cs350/common/old-exams/>Past midterms</a></li></ul><div><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#concepts>Concepts</a></li><li><a href=#course-topics>Course Topics</a></li><li><a href=#assignment-helpers>Assignment Helpers</a><ul><li><a href=#cs-350-cli>CS 350 CLI</a></li><li><a href=#how-to-add-to-path>How to add to PATH</a></li><li><a href=#finding-stuff-in-the-kernal-code>Finding stuff in the kernal code</a></li><li><a href=#setting-up-on-a-new-machine>Setting up on a new Machine</a></li><li><a href=#building-the-kernel>Building the kernel</a></li><li><a href=#running-the-kernel-on-a-simulator>Running the kernel on a simulator</a></li><li><a href=#debugging>Debugging</a></li><li><a href=#working-locally>Working locally</a></li><li><a href=#submitting-assignments>Submitting Assignments</a></li><li><a href=#readelf>Readelf</a></li></ul></li><li><a href=#processes>Processes</a><ul><li><a href=#abstractions>Abstractions</a></li><li><a href=#sections>Sections</a></li><li><a href=#creating-processes>Creating processes</a></li><li><a href=#pipes>Pipes</a></li><li><a href=#implementing-processes>Implementing Processes</a></li><li><a href=#context-switch>Context Switch</a></li></ul></li><li><a href=#threads>Threads</a><ul><li><a href=#posix-thread-api>POSIX Thread API</a></li><li><a href=#limitations-of-kernel-threads>Limitations of Kernel Threads</a></li><li><a href=#go-language-routines>Go Language Routines</a></li><li><a href=#implementing-threads-in-os161>Implementing threads in OS/161</a></li></ul></li><li><a href=#concurrency>Concurrency</a><ul><li><a href=#sequential-consistency>Sequential Consistency</a></li><li><a href=#x86-consistency>x86 Consistency</a></li><li><a href=#x86-atomicity>x86 Atomicity</a></li><li><a href=#petersons-solution>Peterson&rsquo;s Solution</a></li><li><a href=#mutexes>Mutexes</a></li><li><a href=#condition-variables>Condition Variables</a></li><li><a href=#semaphores>Semaphores</a></li></ul></li><li><a href=#synchronization>Synchronization</a><ul><li><a href=#motivation>Motivation</a></li><li><a href=#ordering-requirements>Ordering requirements</a></li><li><a href=#mips-spinlocks>MIPS Spinlocks</a></li><li><a href=#atomics-c11>Atomics C11</a></li><li><a href=#cache-coherence>Cache Coherence</a></li><li><a href=#multicore-caches>Multicore Caches</a></li><li><a href=#3-state-coherence-protocol-msi>3-State Coherence Protocol (MSI)</a></li><li><a href=#core-and-bus-actions>Core and Bus Actions</a></li><li><a href=#multithreaded-design>Multithreaded Design</a></li><li><a href=#deadlocks>Deadlocks</a></li><li><a href=#solving-deadlocks>Solving Deadlocks</a></li><li><a href=#wait-channels>Wait Channels</a></li></ul></li><li><a href=#system-calls>System Calls</a><ul><li><a href=#privilege-modes>Privilege Modes</a></li><li><a href=#mode-transitions>Mode Transitions</a></li><li><a href=#system-call-handling>System Call Handling</a></li><li><a href=#hardware-handling-in-mips-r3000>Hardware Handling in MIPS R3000</a></li><li><a href=#mips-review>MIPS Review</a></li><li><a href=#application-binary-interface>Application Binary Interface</a></li><li><a href=#execution-contexts>Execution Contexts</a></li><li><a href=#preemption>Preemption</a></li><li><a href=#process-context-switch>Process Context Switch</a></li></ul></li><li><a href=#virtual-memory-hardware>Virtual Memory Hardware</a><ul><li><a href=#sharing-memory-issues>Sharing Memory Issues</a></li><li><a href=#virtual-memory-goals>Virtual Memory Goals</a></li><li><a href=#virtual-memory-advantages>Virtual Memory Advantages</a></li><li><a href=#load-time-linking>Load-time Linking</a></li><li><a href=#base--bound-register>base + bound register</a></li><li><a href=#segmentation>Segmentation</a></li><li><a href=#fragmentation>Fragmentation</a></li><li><a href=#paging>Paging</a></li><li><a href=#mmus>MMUs</a></li><li><a href=#hardware-managed-mmu>Hardware Managed MMU</a></li><li><a href=#tlb>TLB</a></li><li><a href=#os>OS</a></li><li><a href=#software-managed-mmu>Software Managed MMU</a></li></ul></li><li><a href=#virtual-memory-os>Virtual Memory OS</a><ul><li><a href=#increasing-virtual-memory-by-paging>Increasing Virtual Memory by Paging</a></li><li><a href=#page-buffering>Page Buffering</a></li><li><a href=#page-allocation>Page Allocation</a></li><li><a href=#thrashing>Thrashing</a></li></ul></li><li><a href=#scheduling>Scheduling</a><ul><li><a href=#cpu-scheduling>CPU Scheduling</a></li><li><a href=#first-come-first-served>First Come First Served</a></li><li><a href=#bursts-of-computation-and-io>Bursts of Computation and I/O</a></li><li><a href=#shortest-job-first>Shortest Job First</a></li><li><a href=#round-robin>Round Robin</a></li><li><a href=#time-quantum>Time Quantum</a></li><li><a href=#priority-scheduling>Priority Scheduling</a></li><li><a href=#multilevel-feedback-queue>Multilevel Feedback Queue</a></li><li><a href=#priority-donation>Priority Donation</a></li><li><a href=#borrowed-virtual-time-scheduler>Borrowed Virtual Time Scheduler</a></li><li><a href=#sleep--wakeup>Sleep / Wakeup</a></li><li><a href=#real-time-threads>Real-time Threads</a></li></ul></li><li><a href=#io>I/O</a><ul><li><a href=#memory-and-io-buses>Memory and I/O buses</a></li><li><a href=#memory-types>Memory Types</a></li><li><a href=#device-communication>Device Communication</a></li><li><a href=#driver-architecture>Driver Architecture</a></li></ul></li><li><a href=#disks-io-subtopic>Disks (I/O Subtopic)</a><ul><li><a href=#disk-positioning-system>Disk Positioning System</a></li><li><a href=#seeking>Seeking</a></li><li><a href=#sectors>Sectors</a></li><li><a href=#disk-interface>Disk Interface</a></li><li><a href=#buses>Buses</a></li><li><a href=#scsi-requests>SCSI Requests</a></li><li><a href=#scsi-exceptions>SCSI Exceptions</a></li><li><a href=#disk-performance>Disk Performance</a></li><li><a href=#disk-scheduling>Disk Scheduling</a></li><li><a href=#flash-memory>Flash Memory</a></li></ul></li><li><a href=#filesystem>Filesystem</a><ul><li><a href=#files-name-bytes-on-disk>Files: name bytes on disk</a></li><li><a href=#mappings>Mappings</a></li><li><a href=#intuitions>Intuitions</a></li><li><a href=#common-patterns>Common Patterns</a></li><li><a href=#dos-fs>DOS FS</a></li><li><a href=#indexed-files>Indexed files</a></li><li><a href=#multi-level-indexed-files>Multi-level indexed files</a></li><li><a href=#directories>Directories</a></li><li><a href=#hard-and-soft-links>Hard and soft links</a></li><li><a href=#fast-file-system-ffs>Fast File System (FFS)</a></li><li><a href=#log-structured-file-system>Log-Structured File System</a></li><li><a href=#metadata-synchronously>Metadata Synchronously</a></li></ul></li><li><a href=#the-slab-allocator>The Slab Allocator</a><ul><li><a href=#object-caching>Object Caching</a></li><li><a href=#questions>Questions</a></li></ul></li><li><a href=#the-fast-file-system>The Fast File System</a></li></ul></nav></div><h2 id=concepts>Concepts
<span><a href=#concepts><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><ul><li>Operating Systems</li><li>Distributed Systems</li><li>Networking</li><li>Internet of Things</li><li>Computer Architecture</li><li>Embedded Systems</li><li>Database Systems</li><li>Systems and Machine Learning</li></ul><h2 id=course-topics>Course Topics
<span><a href=#course-topics><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><ul><li>Threads & Processes</li><li>Concurrency & Synchronization</li><li>Scheduling</li><li>Virtual Memory</li><li>I/O</li><li>Disks, File systems, Network file systems</li><li>Protection & Security</li><li>Unix referenced as an example</li></ul><h2 id=assignment-helpers>Assignment Helpers
<span><a href=#assignment-helpers><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><h3 id=cs-350-cli>CS 350 CLI
<span><a href=#cs-350-cli><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>File hierarchy</p><ul><li>cs350 (CWD)<ul><li>os161</li><li>userspace<ul><li>ASSTUSERX</li></ul></li><li><a href=https://gist.github.com/elibroftw/36d18406d6be775e2c52af9d19571c42>cs350_cli.py</a></li></ul></li></ul><h3 id=how-to-add-to-path>How to add to PATH
<span><a href=#how-to-add-to-path><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>In your <code>.bashrc</code>, add <code>PATH="$PATH:path"</code>. For some reason, my <code>.bashrc</code> file keeps getting wiped.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#40ffff>PATH</span>=<span style=color:#ed9d13>&#34;</span><span style=color:#40ffff>$PATH</span><span style=color:#ed9d13>:/u/cs350/sys161/bin:/u/cs350/bin&#34;</span>
</span></span></code></pre></div><h3 id=finding-stuff-in-the-kernal-code>Finding stuff in the kernal code
<span><a href=#finding-stuff-in-the-kernal-code><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Since you may not have vscode open for the kernel but your entire linux environment, grep may be more efficient.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>grep -rnw . -e <span style=color:#ed9d13>&#39;pattern&#39;</span>
</span></span></code></pre></div><p>This is the command assumes you are in the os161-X.YZ directory.</p><h3 id=setting-up-on-a-new-machine>Setting up on a new Machine
<span><a href=#setting-up-on-a-new-machine><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Works even if a custom directory is used for OS/161</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#999;font-style:italic># setup new machine</span>
</span></span><span style=display:flex><span>./cs350_cli.py configure
</span></span></code></pre></div><p>This will copy the sys161.conf file. You will need to edit the CPUs and memory line. I recommend editing one of the commented out lines to have 4 CPUs and 4MB of memory and another one to be 4 CPUs with 2MB of memory.</p><h3 id=building-the-kernel>Building the kernel
<span><a href=#building-the-kernel><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#999;font-style:italic># configure new assignment (run once per assignment)</span>
</span></span><span style=display:flex><span>./cs350_cli.py new <span style=color:#3677a9>1</span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic># build the kernel for an assignment</span>
</span></span><span style=display:flex><span>./cs350_cli.py build <span style=color:#3677a9>1</span>
</span></span></code></pre></div><p>If you don&rsquo;t use the script I wrote, you can <del>do the following</del> read the source code or the course guide and figure out how to build the kernel manually. I&rsquo;m purposely not providing the commands as I never used them after I wrote my script.</p><h3 id=running-the-kernel-on-a-simulator>Running the kernel on a simulator
<span><a href=#running-the-kernel-on-a-simulator><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#999;font-style:italic># run the last built? kernel or the one you choose</span>
</span></span><span style=display:flex><span>./cs350_cli.py run [uint]
</span></span></code></pre></div><h3 id=debugging>Debugging
<span><a href=#debugging><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#999;font-style:italic># gdb requires you to run the following in two different terminals</span>
</span></span><span style=display:flex><span>./cs350_cli.py debug <span style=color:#3677a9>2</span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic># second terminal. The everything before --breakpoints is mandatory</span>
</span></span><span style=display:flex><span>./cs350_cli.py debug attach <span style=color:#3677a9>2</span> --breakpoints file.c:30 file2.c:50
</span></span></code></pre></div><p>In the second terminal, either spam the enter key or enter c to continue code execution as GDB pauses program.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>(gdb) c
</span></span></code></pre></div><p>See <a href=http://www.student.cs.uwaterloo.ca/~cs350/common/gdb.html>Debugging with GDB</a>.</p><h3 id=working-locally>Working locally
<span><a href=#working-locally><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>To work locally, you will need docker.</p><h3 id=submitting-assignments>Submitting Assignments
<span><a href=#submitting-assignments><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#999;font-style:italic># submit and see grade later</span>
</span></span><span style=display:flex><span>./cs350_cli.py submit <span style=color:#3677a9>0</span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic># internally calls:</span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>#   cs350_submit os161/os161-1.99/kern/compile/ASST0 ASST0</span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>#   cs350_submit userspace/ASSTUSER0 ASSTUSER0</span>
</span></span><span style=display:flex><span>./cs350_cli.py grade <span style=color:#3677a9>0</span>
</span></span></code></pre></div><h3 id=readelf>Readelf
<span><a href=#readelf><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>You can use readelf to get metadata of a binary</p><h2 id=processes>Processes
<span><a href=#processes><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><ul><li>A <em>process</em> is an instance of a program running</li><li>Processes can spawn child processes</li><li>Utilizes CPU better (throughput), lower latency</li><li>Simplicity of programming</li><li>Own view of the machine with abstractions</li><li>Programs don&rsquo;t care which other programs are running</li><li>Pointers are only relevant to one process</li></ul><h3 id=abstractions>Abstractions
<span><a href=#abstractions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>address space</li><li>open files</li><li>virtual CPU</li></ul><h3 id=sections>Sections
<span><a href=#sections><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Programs have sections such as data and text</p><h3 id=creating-processes>Creating processes
<span><a href=#creating-processes><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Posix system calls available in <code>unistd.h</code></p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>fork</span>(<span style=color:#6ab825;font-weight:700>void</span>);
</span></span></code></pre></div><p>Creates a new process that is an exact copy of current one. Return process ID (PID) of new process to the parent. Returns 0 in child.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>waitpid</span>(<span style=color:#6ab825;font-weight:700>int</span> pid, <span style=color:#6ab825;font-weight:700>int</span> *stat, <span style=color:#6ab825;font-weight:700>int</span> opt);
</span></span></code></pre></div><p>wait for process with id pid (-1 for any), set stat to the exit value, and opt is 0 or WNOHANG. Returns PID or -1 on error.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>exit</span>(<span style=color:#6ab825;font-weight:700>int</span> status)
</span></span></code></pre></div><p>Current process ceases to exist. non-zero is error by convention.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>kill</span>(<span style=color:#6ab825;font-weight:700>int</span> pid, <span style=color:#6ab825;font-weight:700>int</span> sig);
</span></span></code></pre></div><p>Sends signal sig to process pid. SIGTERM most common value, application can catch it for cleanup. SIGKILL stronger as it always kills the process. HUP stands for hang up or &ldquo;reload configuration.&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>execve</span>(<span style=color:#6ab825;font-weight:700>char</span> *prog, <span style=color:#6ab825;font-weight:700>char</span> **argv, <span style=color:#6ab825;font-weight:700>char</span> **envp);
</span></span><span style=display:flex><span>prog - absolute path of program run
</span></span><span style=display:flex><span>argv - arguments to pass to main
</span></span><span style=display:flex><span>envp - environment variables
</span></span></code></pre></div><p>Usually called through wrapper functions. Executes new program. Does not spawn that program. Replaces current program with that program.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>execvp</span>(<span style=color:#6ab825;font-weight:700>char</span> *prog, <span style=color:#6ab825;font-weight:700>char</span> **argv)
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// Searches PATH for prog
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>execlp</span>(<span style=color:#6ab825;font-weight:700>char</span> *prog, <span style=color:#6ab825;font-weight:700>char</span> *arg, ...)l
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// List arguments one at a time, finish with NULL
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>dup2</span>(<span style=color:#6ab825;font-weight:700>int</span> oldfd, <span style=color:#6ab825;font-weight:700>int</span> newfd);
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// closes newfd if it was a valid descriptor
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// makes newfd an exact copy of oldfd
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// same offset on both
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// stdin is 0, stdout is 1, stderr is 2.
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>fcntl</span>(<span style=color:#6ab825;font-weight:700>int</span> fd, F_SETFD, <span style=color:#6ab825;font-weight:700>int</span> val);
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// sets close on exec flag if val = 1, clears if val = 0
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// sets file descriptor non-inheritable by new program
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#447fcf>perror</span>(<span style=color:#6ab825;font-weight:700>char</span> * arg)
</span></span></code></pre></div><p>Error friendly print</p><h3 id=pipes>Pipes
<span><a href=#pipes><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pipe</span>(it fds[<span style=color:#3677a9>2</span>]);
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// returns two file descriptors in fds[0] and fds[1]
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// writes to fds[1] will be read on fds[0]
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// fds[0] returns EOF after last copy of fds[1] closes
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// -1 is error, 0 is success
</span></span></span></code></pre></div><p>pipesh.c</p><p>Use dup2 to read from the pipe[1] and write from the pipe[0] while maintaining the stdout and stdin. stderr is 2.</p><h3 id=implementing-processes>Implementing Processes
<span><a href=#implementing-processes><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Process Control Block (PCB) is kept for each process</li><li><code>proc</code> in Unix, <code>task_struct</code> in Linux, <code>struct thread</code> in OS/161</li><li>Tracks state of process<ul><li>new and terminated at beginning & end of life</li><li>running</li><li>ready - can run, but kernel has chosen different process to run</li><li>waiting</li></ul></li><li>Information necessary to run (registers, virtual memory mapping, etc, open files)</li><li>Other data like credentials, signal mask, controlling terminal, priority, accounting stats, debugged, binary emulation, &mldr;</li></ul><h3 id=context-switch>Context Switch
<span><a href=#context-switch><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Saving program counter and integer registers (Always)</li><li>Special registers</li><li>Condition codes</li><li>Change virtual address translations</li></ul><p>Non-negligible cost</p><ul><li>Save/restore floating point registers expensive</li><li>Flushing TLB (memory translation hardware)<ul><li>HW Optimization 1: Don&rsquo;t flush kernel&rsquo;s own data from TLB</li><li>HW Optimization 2: use tag to avoid flushing any data</li></ul></li><li>Cache misses</li></ul><h2 id=threads>Threads
<span><a href=#threads><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><ul><li>Multi-threaded programs share the address space.</li><li>Typically one kernel thread for every process</li></ul><h3 id=posix-thread-api>POSIX Thread API
<span><a href=#posix-thread-api><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#999;font-style:italic>// create a new thread identified by thr with optional attributes, run fn with arg
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_create</span>(<span style=color:#6ab825;font-weight:700>pthread_t</span> *thr, <span style=color:#6ab825;font-weight:700>pthread_attr_t</span> *attr, <span style=color:#6ab825;font-weight:700>void</span> *(*fn)(<span style=color:#6ab825;font-weight:700>void</span> *), <span style=color:#6ab825;font-weight:700>void</span> *arg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// destroy current thread and return a pointer
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>pthread_exit</span>(<span style=color:#6ab825;font-weight:700>void</span> *return_value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// Wait for thread thread to exit and receive the return value
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_join</span>(<span style=color:#6ab825;font-weight:700>pthread_t</span> <span style=color:#6ab825;font-weight:700>thread</span>, <span style=color:#6ab825;font-weight:700>void</span> **return_value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// tell the OS scheduler to run another thread or process
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>pthread_yield</span>();
</span></span></code></pre></div><p>and more</p><h3 id=limitations-of-kernel-threads>Limitations of Kernel Threads
<span><a href=#limitations-of-kernel-threads><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>syscalls take 100 cycles, function calls take 2 cycles</li><li>fixed-size stack within kernel</li></ul><h3 id=go-language-routines>Go Language Routines
<span><a href=#go-language-routines><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>lightweight, 100k go routines is practical</li></ul><h3 id=implementing-threads-in-os161>Implementing threads in OS/161
<span><a href=#implementing-threads-in-os161><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>thread_fork</span>(<span style=color:#6ab825;font-weight:700>const</span> <span style=color:#6ab825;font-weight:700>char</span> *name, <span style=color:#6ab825;font-weight:700>struct</span> proc *proc,
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>void</span> (*entrypoint)(<span style=color:#6ab825;font-weight:700>void</span> *data1, <span style=color:#6ab825;font-weight:700>unsigned</span> <span style=color:#6ab825;font-weight:700>long</span> data2), <span style=color:#6ab825;font-weight:700>void</span> *data1, <span style=color:#6ab825;font-weight:700>unsigned</span> <span style=color:#6ab825;font-weight:700>long</span> data2)
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// wrapper for pthread_create wrapper, does not call process fork
</span></span></span></code></pre></div><h2 id=concurrency>Concurrency
<span><a href=#concurrency><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>Data races occur without synchronization</p><p>Options:</p><ul><li>Atomic instructions: instantaneously modify a value</li><li>Locks: prevent concurrent execution</li></ul><h3 id=sequential-consistency>Sequential Consistency
<span><a href=#sequential-consistency><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Execution as if all operations were executed in some sequential order and that the operations of each processor occurred in the order specified by the program.</p><p>Requirements for sequential consistency are maintaining program order on individual processors and ensuring writes are atomic.</p><ul><li>Sequential consistency complicates write buffers since CPUs use many caches.</li><li>We want to group writes to the same location (coalescing)</li><li>Complicates non-blocking reads</li><li>Thwarting of compiler optimizations</li></ul><p>Does not solve the problem of atomicity since modifying a value is 3 lines of code.</p><h3 id=x86-consistency>x86 Consistency
<span><a href=#x86-consistency><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Different choice for how to write like (cache, write cache and memory, write to memory only, uncacheable).</p><h3 id=x86-atomicity>x86 Atomicity
<span><a href=#x86-atomicity><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li><code>lock</code> - prefix to make a memory instruction atomic (locks bus for duration of instruction)<ul><li>can avoid locking if memory already exclusively cached</li><li>all lock instructions totally ordered</li><li>other memory instructions cannot be re-ordered w. locked ones</li><li>locks are always ordered</li></ul></li><li><code>xchg</code></li><li><code>cmpxchg</code></li><li><code>lfence</code></li><li><code>sfence</code></li><li><code>mfence</code></li></ul><h3 id=petersons-solution>Peterson&rsquo;s Solution
<span><a href=#petersons-solution><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Assuming sequential consistency</li><li>Assume two threads</li><li><code>int not_turn</code></li><li><code>bool wants[2]</code></li></ul><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>  wants[i] = <span style=color:#24909d>true</span>;
</span></span><span style=display:flex><span>  not_turn = i;
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>while</span>(wants[<span style=color:#3677a9>1</span>-i] &amp;&amp; not_turn == i)
</span></span><span style=display:flex><span>    <span style=color:#999;font-style:italic>// other thread wants in and not our turn
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>  <span style=color:#447fcf>Critical_section</span>();
</span></span><span style=display:flex><span>  wants[i] = <span style=color:#24909d>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>Remainder_section</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=mutexes>Mutexes
<span><a href=#mutexes><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>A mutex is a mutual exclusion lock. Thread packages typically provide <em>mutexes</em>:</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_mutex_init</span>(<span style=color:#6ab825;font-weight:700>pthread_mutex_t</span>  *m, <span style=color:#6ab825;font-weight:700>pthread_mutexattr_t</span> attr);
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_mutex_destroy</span>(<span style=color:#6ab825;font-weight:700>pthread_mutex_t</span> *m)
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_mutex_lock</span> (<span style=color:#6ab825;font-weight:700>pthread_mutex_t</span>  *m);
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_mutex_unlock</span>(<span style=color:#6ab825;font-weight:700>pthread_mutex_t</span> *m)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// return 0 if successful, otherwise -1 (errno == EBUSY)
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_mutex_trylock</span> (<span style=color:#6ab825;font-weight:700>pthread_mutex_t</span>  *m);
</span></span></code></pre></div><p>Only one thread acquires m at a time, others wait. All global data should be protected by a mutex. If mutexes are used properly, then we get behavior equivalent to sequential consistency.</p><p>Want to wrap all shared memory writes with a mutex lock and unlock.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#999;font-style:italic>// Improved Producer
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>mutex_t</span> mutex = MUTEX_INITIALIZER;
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>producer</span> (<span style=color:#6ab825;font-weight:700>void</span> *ignored) {
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>    item *nextProduced = <span style=color:#447fcf>produce_item</span> ();
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_lock</span> (&amp;mutex);
</span></span><span style=display:flex><span>    <span style=color:#6ab825;font-weight:700>while</span> (count == BUFFER_SIZE) {  <span style=color:#999;font-style:italic>// remember to do while and not if
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>      <span style=color:#447fcf>mutex_unlock</span> (&amp;mutex);              <span style=color:#999;font-style:italic>// allow other threads to lock
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>      <span style=color:#447fcf>thread_yield</span> ();
</span></span><span style=display:flex><span>      <span style=color:#447fcf>mutex_lock</span> (&amp;mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    buffer [in] = nextProduced;
</span></span><span style=display:flex><span>    in = (in + <span style=color:#3677a9>1</span>) % BUFFER_SIZE;
</span></span><span style=display:flex><span>    count++;
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_unlock</span> (&amp;mutex);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// Improved Consumer
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>consumer</span> (<span style=color:#6ab825;font-weight:700>void</span> *ignored) {
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_lock</span> (&amp;mutex);
</span></span><span style=display:flex><span>    <span style=color:#6ab825;font-weight:700>while</span> (count == <span style=color:#3677a9>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#447fcf>mutex_unlock</span> (&amp;mutex);
</span></span><span style=display:flex><span>      <span style=color:#447fcf>thread_yield</span> ();
</span></span><span style=display:flex><span>      <span style=color:#447fcf>mutex_lock</span> (&amp;mutex);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  item *nextConsumed = buffer[out];
</span></span><span style=display:flex><span>  out = (out + <span style=color:#3677a9>1</span>) % BUFFER_SIZE;
</span></span><span style=display:flex><span>  count--;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>mutex_unlock</span> (&amp;mutex);
</span></span><span style=display:flex><span>  <span style=color:#447fcf>consume_item</span> (nextConsumed);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=condition-variables>Condition Variables
<span><a href=#condition-variables><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Busy-waiting in application is a bad idea, since it consumes CPU. Instead of calling <code>thread_yield</code>, we can sleep until a condition is met.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_cond_init</span>(<span style=color:#6ab825;font-weight:700>pthread_cond_t</span> *, ...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// unlock&#39;s m atomically and re-acquires it upon signal
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_cond_wait</span>(<span style=color:#6ab825;font-weight:700>pthread_cond_t</span> *c, <span style=color:#6ab825;font-weight:700>pthread_mutex_t</span> *m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// wake a single thread up
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_cond_signal</span>(<span style=color:#6ab825;font-weight:700>pthread_cond_t</span> *c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// wake all threads up (one at a time though)
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>pthread_cond_broadcast</span>(<span style=color:#6ab825;font-weight:700>pthread_cond_t</span> *c);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>mutex_t</span> mutex = MUTEX_INITIALIZER;
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>cond_t</span> nonempty = COND_INITIALIZER;
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>cond_t</span> nonfull = COND_INITIALIZER;
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// CV Producer
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>producer</span> (<span style=color:#6ab825;font-weight:700>void</span> *ignored) {
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>    item *nextProduced = <span style=color:#447fcf>produce_item</span> ();
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_lock</span>(&amp;mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#999;font-style:italic>// remember to use WHILE to avoid race conditions
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>while</span> (count == BUFFER_SIZE)
</span></span><span style=display:flex><span>      <span style=color:#447fcf>cond_wait</span>(&amp;nonfull, &amp;mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    buffer [in] = nextProduced;
</span></span><span style=display:flex><span>    in = (in + <span style=color:#3677a9>1</span>) % BUFFER_SIZE;
</span></span><span style=display:flex><span>    count++;
</span></span><span style=display:flex><span>    <span style=color:#447fcf>cond_signal</span>(&amp;nonempty);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_unlock</span>(&amp;mutex);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// CV Consumer
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>consumer</span> (<span style=color:#6ab825;font-weight:700>void</span> *ignored) {
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_lock</span> (&amp;mutex);
</span></span><span style=display:flex><span>    <span style=color:#999;font-style:italic>// remember to use WHILE to avoid race conditions
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>while</span> (count == <span style=color:#3677a9>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#447fcf>cond_wait</span> (&amp;nonempty, &amp;mutex);
</span></span><span style=display:flex><span>    item *nextConsumed = buffer[out];
</span></span><span style=display:flex><span>    out = (out + <span style=color:#3677a9>1</span>) % BUFFER_SIZE;
</span></span><span style=display:flex><span>    count--;
</span></span><span style=display:flex><span>    <span style=color:#447fcf>cond_signal</span> (&amp;nonfull);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>mutex_unlock</span> (&amp;mutex);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>consume_item</span> (nextConsumed);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Use a while loop with these conditions to avoid race conditions of being beat out by another consumer.</p><h3 id=semaphores>Semaphores
<span><a href=#semaphores><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>A Semaphore is initialized with an integer N.</li><li><code>sem_wait</code> will return only N more times
than <code>sem_signal</code> called<ul><li>first N calls to <code>sem_wait</code> do not block</li></ul></li></ul><p>Fancy mutex where if n == 0, sem_wait will block.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> <span style=color:#447fcf>sem_init</span>(<span style=color:#6ab825;font-weight:700>sem_t</span> *s, ..., <span style=color:#6ab825;font-weight:700>unsigned</span> <span style=color:#6ab825;font-weight:700>int</span> n); <span style=color:#999;font-style:italic>// proc_count_mutex = sem_create(&#34;proc_count_mutex&#34;,1);
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#447fcf>sem_wait</span>(<span style=color:#6ab825;font-weight:700>sem_t</span> *s) (originally called P)  <span style=color:#999;font-style:italic>// P(sem_t *s)
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#447fcf>sem_signal</span>(<span style=color:#6ab825;font-weight:700>sem_t</span> *s)  <span style=color:#999;font-style:italic>// V(sem_t *s)
</span></span></span></code></pre></div><h2 id=synchronization>Synchronization
<span><a href=#synchronization><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><h3 id=motivation>Motivation
<span><a href=#motivation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><img class=equation-tall src="https://latex.codecogs.com/svg.image?T(n)=T(1)(B+\frac{1}{n}(1-B))"><ul><li><p>Amdahl&rsquo;s law</p><ul><li>T(1): the time one core takes to complete the task</li><li>B: the fraction of the job that must be serial</li><li>n: number of cores<ul><li>Imagine if n was infinity</li></ul></li><li>Ultimate limit on parallel speedup</li><li>Synchronization increases serial section size</li></ul></li><li><p>Locking basics</p><ul><li>Lock whenever critical section is required and at least one is writing</li></ul></li></ul><h3 id=ordering-requirements>Ordering requirements
<span><a href=#ordering-requirements><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>while</span> (<span style=color:#447fcf>test_and_set</span> (&amp;v-&gt;lock))
</span></span><span style=display:flex><span>  ; <span style=color:#999;font-style:italic>// ensure lock is acquired before writing
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>v-&gt;val++;
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// this tells the compiler not to reorder
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>asm</span> <span style=color:#447fcf>volatile</span> (<span style=color:#ed9d13>&#34;sfence&#34;</span> ::: <span style=color:#ed9d13>&#34;memory&#34;</span>);
</span></span><span style=display:flex><span>v-&gt;lock = <span style=color:#3677a9>0</span>;
</span></span></code></pre></div><h3 id=mips-spinlocks>MIPS Spinlocks
<span><a href=#mips-spinlocks><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> spinlock_acquire {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>while</span>(<span style=color:#3677a9>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#999;font-style:italic>// first check if the lock is busy to reduce coherence traffic
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>if</span> (<span style=color:#447fcf>spinlock_data_get</span>(&amp;lk-&gt;lk_lock) != <span style=color:#3677a9>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#6ab825;font-weight:700>continue</span>; <span style=color:#999;font-style:italic>// saves CPU cycles
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>    <span style=color:#999;font-style:italic>// attempt to acquire lock
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span>    <span style=color:#6ab825;font-weight:700>if</span> (<span style=color:#447fcf>spinlock_data_testandset</span>(&amp;lk-&gt;lk_lock) != <span style=color:#3677a9>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#6ab825;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    <span style=color:#6ab825;font-weight:700>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  lk-&gt;lk_holder = mycpu;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=atomics-c11>Atomics C11
<span><a href=#atomics-c11><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Portable support for atomics.</p><p>To implement mutexes you need atomics. Atomics guarantee
something will be written before the next line. (fences). With an Atomic type, all standard ops become sequentially consistent. There&rsquo;s also a variety of memory ordering from no memory ordering to full sequential consistency.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#447fcf>_Atomic</span>(<span style=color:#6ab825;font-weight:700>int</span>) variable_name = <span style=color:#3677a9>1</span>;
</span></span><span style=display:flex><span><span style=color:#447fcf>atomic_fetch_add_explicit</span>(&amp;variable_name, <span style=color:#3677a9>1</span>, memory_order_relaxed);
</span></span><span style=display:flex><span><span style=color:#447fcf>atomic_fetch_add_explicit</span>(&amp;variable_name, -<span style=color:#3677a9>1</span>, memory_order_relaxed);
</span></span><span style=display:flex><span><span style=color:#447fcf>atomic_thread_fence</span>(memory_order_release);
</span></span><span style=display:flex><span><span style=color:#447fcf>atomic_store_explicit</span>(&amp;variable_name, <span style=color:#3677a9>0</span>, memory_order_relaxed);
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span>  x = <span style=color:#447fcf>atomic_load_explicit</span>(&amp;variable_name);
</span></span><span style=display:flex><span><span style=color:#447fcf>atomic_thread_fence</span>(memory_order_acquire);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#447fcf>_Atomic</span>(<span style=color:#6ab825;font-weight:700>int</span>) packet_count;
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>recv_packet</span>(...) {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  <span style=color:#447fcf>atomic_fetch_add_explicit</span>(&amp;packet_count, <span style=color:#3677a9>1</span>, memory_order_relaxed);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>struct</span> message msg_buf;
</span></span><span style=display:flex><span><span style=color:#447fcf>_Atomic</span>(_Bool) msg_ready;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>send</span>(<span style=color:#6ab825;font-weight:700>struct</span> message *m) {
</span></span><span style=display:flex><span>  msg_buf = *m;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>atomic_thread_fence</span>(memory_order_release);
</span></span><span style=display:flex><span>  <span style=color:#447fcf>atomic_store_explicit</span>(&amp;msg_ready, <span style=color:#3677a9>1</span>,
</span></span><span style=display:flex><span>  memory_order_relaxed);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>struct</span> message *<span style=color:#447fcf>recv</span>(<span style=color:#6ab825;font-weight:700>void</span>) {
</span></span><span style=display:flex><span>  _Bool ready = <span style=color:#447fcf>atomic_load_explicit</span>(&amp;msg_ready,
</span></span><span style=display:flex><span>  memory_order_relaxed);
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>if</span> (!ready)
</span></span><span style=display:flex><span>    <span style=color:#6ab825;font-weight:700>return</span> <span style=color:#24909d>NULL</span>;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>atomic_thread_fence</span>(memory_order_acquire);
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>return</span> &amp;msg_buf;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Spinlock example. The atomic_flag is a special type without support for loads and store. Implemented lock free.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>spin_lock</span>(atomic_flag *lock) {
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>while</span>(<span style=color:#447fcf>atomic_flag_test_and_set_explicit</span>(lock, memory_order_acquire)) {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>spin_unlock</span>(atomic_flag *lock) {
</span></span><span style=display:flex><span>  <span style=color:#447fcf>atomic_flag_clear_explicit</span>(lock, memory_order_release);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=cache-coherence>Cache Coherence
<span><a href=#cache-coherence><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>coherence means accesses to single memory location</li><li>consistency means ordering between multiple locations</li></ul><h3 id=multicore-caches>Multicore Caches
<span><a href=#multicore-caches><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Cache = performance but presents an opportunity for cores to disagree about memory. Cache is divided into chunks of bytes called cache lines. Bus or network is used.</p><h3 id=3-state-coherence-protocol-msi>3-State Coherence Protocol (MSI)
<span><a href=#3-state-coherence-protocol-msi><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Cache lines have 3 states</p><ul><li>Modified<ul><li>One cache has a copy needs to be written back to memory</li></ul></li><li>Shared<ul><li>At least one cache have a valid copy</li></ul></li><li>Invalid<ul><li>No data</li></ul></li></ul><h3 id=core-and-bus-actions>Core and Bus Actions
<span><a href=#core-and-bus-actions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Read (load)<ul><li>Cacheline enters shared state as data is read without modification intent and could come from cache or memory</li><li>Write (store)<ul><li>Invalidates other cache copies</li><li>Cacheline in shared</li></ul></li><li>Evict<ul><li>Writeback contents to memory if not dirty</li><li>Discard if in shared state</li></ul></li></ul></li></ul><h3 id=multithreaded-design>Multithreaded Design
<span><a href=#multithreaded-design><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Avoid false sharing: avoid placing data used by different threads in the same cache line.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>int</span> lock;
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>char</span> _uused[bytes];        <span style=color:#999;font-style:italic>// before C11 / C++ 11 manual padding
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#447fcf>alignas</span>(<span style=color:#3677a9>64</span>) <span style=color:#6ab825;font-weight:700>struct</span> foo f;  <span style=color:#999;font-style:italic>// C11 / C++ 11
</span></span></span></code></pre></div><p>Avoid contending on cache lines.</p><h3 id=deadlocks>Deadlocks
<span><a href=#deadlocks><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Both threads must lock and unlock in the same order.</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#447fcf>lock</span>(a);
</span></span><span style=display:flex><span><span style=color:#447fcf>lock</span>(b);
</span></span><span style=display:flex><span><span style=color:#447fcf>unlock</span>(b);
</span></span><span style=display:flex><span><span style=color:#447fcf>unlock</span>(a);
</span></span></code></pre></div><h3 id=solving-deadlocks>Solving Deadlocks
<span><a href=#solving-deadlocks><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Avoid circular graphs</li><li>Predefine an order in which each lock should be acquired</li><li>You can use the address of the lock to determine locking order</li><li>When there is a circularity, use a system wide lock or a partial ordering</li><li>Can assert locking order statically (VMware ESX)</li></ul><h3 id=wait-channels>Wait Channels
<span><a href=#wait-channels><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#999;font-style:italic>// blocks calling thread on wait channel wc
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>wchan_sleep</span>(<span style=color:#6ab825;font-weight:700>struct</span> wchan *wc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// wakes all threads sleeping on the wait channel
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>wchan_wakeall</span>(<span style=color:#6ab825;font-weight:700>struct</span> wchan *wc):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// unblocks one threads sleeping on the wait channel
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>wchan_wakeone</span>(<span style=color:#6ab825;font-weight:700>struct</span> wchan *wc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// lock wait channel operations
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// prevents a race between sleep and wakeone
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>wchan_lock</span>(<span style=color:#6ab825;font-weight:700>struct</span> wchan *wc);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#999;font-style:italic>// wait
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#447fcf>P</span>(<span style=color:#6ab825;font-weight:700>struct</span> semaphore *sem) {
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_acquire</span>(&amp;sem-&gt;sem_lock);
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>while</span> (sem-&gt;sem_count == <span style=color:#3677a9>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#447fcf>wchan_lock</span>(sem-&gt;sem_wchan);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>spinlock_release_</span>(&amp;sem-&gt;sem_lock);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>wchan_sleep</span>(sem-&gt;sem_wchan);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>spinlock_acquire</span>(&amp;sem-&gt;sem_lock);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  sem-&gt;sem_count--;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_release</span>(&amp;sem-&gt;sem_lock);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#999;font-style:italic>// signal
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic></span><span style=color:#447fcf>V</span>(<span style=color:#6ab825;font-weight:700>struct</span> semaphore *sem) {
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_acquire</span>(&amp;sem-&gt;sem_lock)
</span></span><span style=display:flex><span>  sem-&gt;count++;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>wchan_wakeone</span>(sem-&gt;sem_wchan);
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_release</span>(&amp;sem-&gt;sem_lock);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><details><summary>Mutex Lock Implementation</summary><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>struct</span> lock {
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>struct</span> wchan *wc;
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>struct</span> spinlock lock;
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>int</span> state;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>lock_acquire</span>(<span style=color:#6ab825;font-weight:700>struct</span> lock *l) {
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_acquire</span>(&amp;l-&gt;lock);
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>while</span>(l-&gt;state) {
</span></span><span style=display:flex><span>    <span style=color:#447fcf>wchan_lock</span>(l-&gt;wc);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>spinlock_release</span>(l-&gt;lock);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>wchan_sleep</span>(l-&gt;wc);
</span></span><span style=display:flex><span>    <span style=color:#447fcf>spinlock_acquire</span>(l-&gt;lock);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  l-&gt;state = <span style=color:#3677a9>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_release</span>(&amp;l-&gt;lock);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>lock_release</span>(<span style=color:#6ab825;font-weight:700>struct</span> lock *l) {
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_acquire</span>(&amp;l-&gt;lock);
</span></span><span style=display:flex><span>  l-&gt;state = <span style=color:#3677a9>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#447fcf>wchan_wakeone</span>(l-&gt;wc);
</span></span><span style=display:flex><span>  <span style=color:#447fcf>spinlock_release</span>(&amp;l-&gt;lock);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details><h2 id=system-calls>System Calls
<span><a href=#system-calls><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>System Calls: Application programmer interface (API) that
programmers use to interact with the operating system. They are also a class of exceptions.</p><ul><li><p>Unprivileged code</p><ul><li>Application</li><li>Syscall Library</li></ul></li><li><p>Privileged</p><ul><li>Kernel</li></ul></li><li><p>sysctl(): Exposes operating system configuration</p></li><li><p>ioctl(): Controlling devices</p></li></ul><h3 id=privilege-modes>Privilege Modes
<span><a href=#privilege-modes><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Kernel / Privileged Mode - Operating System<ul><li>Access all privileged CPU features</li><li>Setup and mange interrupts</li><li>Controls the system call interface</li><li>Modify the TLB (virtual memory &mldr; future lecture)</li></ul></li><li>User Mode - Applications<ul><li>Cannot read/write kernel memory</li><li>Cannot directly call kernel functions</li><li>System library is also kernel memory so library is secure</li></ul></li></ul><h3 id=mode-transitions>Mode Transitions
<span><a href=#mode-transitions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Kernel Mode can only be entered through well defined entry points.</p><h4 id=interrupts>Interrupts
<span><a href=#interrupts><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Generated by external devices needing to signal</li><li>Signal processor through pin or bus message</li><li>Processor executes interrupt handler and preempts running program</li><li>Non-maskable interrupts (NMI) are urgent system requests that cannot be disabled</li></ul><h4 id=exceptions>Exceptions
<span><a href=#exceptions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Caused by processor. E.g. divide by zero, page faults, CPU errors</li><li>Also called faults</li><li>Program errors: Divide-by-zero, illegal instructions</li><li>Operating System Requests: Page Faults</li><li>Hardware Errors: System check (bad memory or CPU failures)</li><li>CPU stops at instruction that triggered the exception</li><li>Control is transferred to a fixed location where the exception handler is located in privledged mode</li></ul><h4 id=mips-exception-vectors>MIPS Exception Vectors
<span><a href=#mips-exception-vectors><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><p>interrupt (0), system call (8), or other exception</p><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>EX_IRQ <span style=color:#3677a9>0</span> <span style=color:#999;font-style:italic>/* Interrupt */</span>
</span></span><span style=display:flex><span>EX_MOD <span style=color:#3677a9>1</span> <span style=color:#999;font-style:italic>/* TLB Modify (write to read-only page) */</span>
</span></span><span style=display:flex><span>EX_TLBL <span style=color:#3677a9>2</span> <span style=color:#999;font-style:italic>/* TLB miss on load */</span>
</span></span><span style=display:flex><span>EX_TLBS <span style=color:#3677a9>3</span> <span style=color:#999;font-style:italic>/* TLB miss on store */</span>
</span></span><span style=display:flex><span>EX_ADEL <span style=color:#3677a9>4</span> <span style=color:#999;font-style:italic>/* Address error on load */</span>
</span></span><span style=display:flex><span>EX_ADES <span style=color:#3677a9>5</span> <span style=color:#999;font-style:italic>/* Address error on store */</span>
</span></span><span style=display:flex><span>EX_IBE <span style=color:#3677a9>6</span> <span style=color:#999;font-style:italic>/* Bus error on instruction fetch */</span>
</span></span><span style=display:flex><span>EX_DBE <span style=color:#3677a9>7</span> <span style=color:#999;font-style:italic>/* Bus error on data load or store */</span>
</span></span><span style=display:flex><span>EX_SYS <span style=color:#3677a9>8</span> <span style=color:#999;font-style:italic>/* Syscall */</span>
</span></span><span style=display:flex><span>EX_BP <span style=color:#3677a9>9</span> <span style=color:#999;font-style:italic>/* Breakpoint */</span>
</span></span><span style=display:flex><span>EX_RI <span style=color:#3677a9>10</span> <span style=color:#999;font-style:italic>/* Illegal instruction */</span>
</span></span><span style=display:flex><span>EX_CPU <span style=color:#3677a9>11</span> <span style=color:#999;font-style:italic>/* Coprocessor unusable */</span>
</span></span><span style=display:flex><span>EX_OVF <span style=color:#3677a9>12</span> <span style=color:#999;font-style:italic>/* Arithmetic overflow */</span>
</span></span></code></pre></div><h3 id=system-call-handling>System Call Handling
<span><a href=#system-call-handling><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>EX_SYS (8) exception</li></ul><ol><li>Application loads the arguments into CPU registers</li><li>Load the system call number into register $v0</li><li>Executes syscall instruction to trigger EX_SYS exception</li><li>Kernel processes the system call through the exception handler</li></ol><ul><li>kernel stack</li><li>create trapframe of the program state</li><li>exception type</li><li>type of system call</li><li>run kernel function</li><li>restore state from trapframe</li></ul><ol start=5><li>Returns to userspace using rfe, return from exception instruction</li></ol><h3 id=hardware-handling-in-mips-r3000>Hardware Handling in MIPS R3000
<span><a href=#hardware-handling-in-mips-r3000><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Fixed location exception handlers</li><li>0x8000_00<strong>00</strong> User TLB Handler (virtual memory)<ul><li>So frequent, handler is hand optimized assembly</li></ul></li><li>0x8000_00<strong>80</strong> general exception handler</li><li>First 512MB of memory is for the OS</li></ul><h4 id=mips-coprocessor>MIPS Coprocessor
<span><a href=#mips-coprocessor><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>MIPS CP0: system control coprocessor<ul><li>System Control Coprocessor (CP0) contains exception handling information</li><li>c0_status</li><li>c0_cause</li><li>c0_epc</li><li>c0_vaddr (fault associated address)</li><li>c0_contex</li></ul></li><li>MIPS CP1 floating point coprocessor</li></ul><h3 id=mips-review>MIPS Review
<span><a href=#mips-review><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>caller-saved registers</li><li>t0-t9: temporary registers</li><li>a0-a3: argument registers</li><li>v0-v1: return values</li><li>s0-s7: callee-saved registers</li><li>jal: jump and link to $ra</li><li>jr $ra: return from function</li><li>registers are saved per-thread stack (stacks are not shared, memories are&mldr;)</li></ul><h3 id=application-binary-interface>Application Binary Interface
<span><a href=#application-binary-interface><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>System call number in v0</li><li>First four arguments in a0, a1, a2, a3</li><li>Remaining arguments passed on the stack</li><li>Success/fail in a3 and return value/error code in v0</li></ul><h4 id=system-call-numbering>System Call Numbering
<span><a href=#system-call-numbering><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><p>Defined in <code>kern/include/kern/syscall.h</code></p><h3 id=execution-contexts>Execution Contexts
<span><a href=#execution-contexts><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>The environment where functions execute including their
arguments, local variables, memory.</p><ul><li>Three types of contexts: Application, kernel, interrupt.</li><li>Context transitions<ul><li>Context switch: a transition between contexts</li><li>Thread switch: a transition between threads</li></ul></li></ul><h4 id=application-stack>Application Stack
<span><a href=#application-stack><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><p>Stack made up of frames that contain locals, arguments, and spilled registers. _start frame.</p><h4 id=context-switch-user-to-kernel>Context Switch User to Kernel
<span><a href=#context-switch-user-to-kernel><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>common_exception saves trapframe of the application context to the kernel stack</li><li>mips_trap decodes the trapframe and the syscall</li><li>syscall decodes arguments and calls sys_write</li><li>syscall stores return value and error into trapframe</li><li>common_exception restores the application context</li></ul><h3 id=preemption>Preemption
<span><a href=#preemption><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Can preempt a process when kernel gets control</li><li>Vector controls through system calls and etc.</li><li>Periodic timer</li><li>Device interrupt</li><li>Changing the running process is called context switch</li><li>Processes can vector control to kernel through exceptions and I/O</li><li>Changing the running process is called a context switch</li></ul><h3 id=process-context-switch>Process Context Switch
<span><a href=#process-context-switch><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Process Control Block</li><li>Save state into first processes&rsquo; PCB</li><li>Reload state from other processes&rsquo; PCB</li><li>Save state into other processes&rsquo; PCB</li><li>Reload state from first processes&rsquo;s PCB</li></ul><h4 id=timer-interrupt>Timer Interrupt
<span><a href=#timer-interrupt><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Like before, except EX_IRQ from timer means</li><li>mainbus_interrupt</li><li>timer_interrupt</li><li>thread_yield to pick next thread</li><li>thread_switch to save kernel thread state and restore thread state</li><li>switchframe</li></ul><h2 id=virtual-memory-hardware>Virtual Memory Hardware
<span><a href=#virtual-memory-hardware><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><h3 id=sharing-memory-issues>Sharing Memory Issues
<span><a href=#sharing-memory-issues><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Protection<ul><li>Bug in one process corrupts memory in another</li><li>Need to also protect against observing other&rsquo;s memory</li></ul></li><li>Transparency<ul><li>A process shouldnt require particular physical memory bits</li></ul></li><li>Resource exhaustion<ul><li>Sum of all processors sizes > physical memory</li></ul></li></ul><h3 id=virtual-memory-goals>Virtual Memory Goals
<span><a href=#virtual-memory-goals><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Applications don&rsquo;t see physical memory, only virutal addresses</li><li>The Memory-Management Unit (hardware) relocates each load<ul><li>The MMU is usually patrt of the CPU</li><li>Accessed w. privileged instructions (e.g., load bound reg)</li><li>Translates from virtual to physical addresses</li><li>Gives per-process view of memory called address space</li></ul></li><li>Prevents one app from messing with anothers memory</li><li>Allows programs to see more memory than exists (relocate memory accesses to disk)</li></ul><h3 id=virtual-memory-advantages>Virtual Memory Advantages
<span><a href=#virtual-memory-advantages><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Can re-locate program while running</li><li>Partially run in memory and on disk</li><li>Idle processes&rsquo; memory written to disk so that other processes can read</li></ul><h3 id=load-time-linking>Load-time Linking
<span><a href=#load-time-linking><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Linker patches addresses of symbols like printf</li><li>How to enforce protection</li><li>How to move once already in memory (Consider: data pointers)</li><li>What if no contiguous free region fits program?</li></ul><h3 id=base--bound-register>base + bound register
<span><a href=#base--bound-register><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Two special privileged registers: base and bound</li><li>When loading/storing,<ul><li>Check 0  virtual address &lt; bound, else trap to kernel</li><li>Physical address = virtual address + base</li></ul></li><li>To move proces in memory, change base register</li><li>OS must reload base and bound register on context switch</li><li>Need to segment memory to avoid<ul><li>expensive process growth</li><li>sharing code/data</li></ul></li></ul><h3 id=segmentation>Segmentation
<span><a href=#segmentation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Each process has may base/bound regs. Address space is built from many segments. Share/protect memory at segment granularity. Segment is specified in a virtual address.</p><ul><li>Segment table<table><thead><tr><th>[Seg]</th><th>base</th><th>bounds</th><th>rw</th></tr></thead><tbody><tr><td>0</td><td>0x4000</td><td>0x6ff</td><td>10</td></tr><tr><td>1</td><td>0x0000</td><td>0x4ff</td><td>11</td></tr><tr><td>2</td><td>0x3000</td><td>0xfff</td><td>11</td></tr><tr><td>3</td><td></td><td></td><td>00</td></tr></tbody></table></li><li>Virtual address indicates segment and an offset<ul><li>top bits of addr corresponds to 0-index row/segment in segment table, low bits select offset</li></ul></li></ul><details><summary>segment exercises: 0x0240, 0x1108, 0x265c, 0x3002, 0x1600</summary><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#3677a9>0x0240</span> --&gt; <span style=color:#3677a9>0x4240</span>
</span></span><span style=display:flex><span><span style=color:#3677a9>0x1108</span> --&gt; <span style=color:#3677a9>0x0108</span>
</span></span><span style=display:flex><span><span style=color:#3677a9>0x265c</span> --&gt; <span style=color:#3677a9>0x365c</span>
</span></span><span style=display:flex><span><span style=color:#3677a9>0x3002</span> --&gt; EXCEPTION
</span></span><span style=display:flex><span><span style=color:#3677a9>0x1600</span> --&gt; OUT OF BOUNDS SINCE <span style=color:#3677a9>0x0600</span> &gt; <span style=color:#3677a9>0x04ff</span>
</span></span></code></pre></div></details><p>If the segment is invalid (not in table or has invalid rw bits), an exception is thrown.</p><ul><li>Requires translation hardware which could limit performance</li><li>Segments not exactly transparent to program</li><li>Segments need contiguous bytes of physical memory</li><li>Leads to fragmentation</li></ul><h3 id=fragmentation>Fragmentation
<span><a href=#fragmentation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>The inability to use free memory.</p><h4 id=external-fragmentation>External Fragmentation
<span><a href=#external-fragmentation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><p>Free memory between segments that is too small to be used</p><h4 id=internal-fragmentation>Internal Fragmentation
<span><a href=#internal-fragmentation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><p>Space inside a segment that was allocated for the stack; internal waste.</p><h3 id=paging>Paging
<span><a href=#paging><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Divide memory up into small pages<ul><li>Map virtual pages to physical pages. Each process has separate mapping</li></ul></li><li>Certain operations give control back to OS<ul><li>writes to read-only pages</li><li>invalid pages</li><li>OS can change mapping</li></ul></li><li>Accessed and dirty bits</li><li>Cache control</li><li>Pages eliminates external fragmentation and pages are small enough that average internal fragmentation is .5 pages per &ldquo;segment&rdquo;</li><li>Pages have a fixed size. X KB<ul><li>log2(X) = bits required for the page offset</li><li>Least significant 12 bits are the offset when page size is 4KB</li></ul></li><li>Each process has a page table that maps Virtual Page Numbers to Physical Page Numbers</li></ul><p><img src=/images/cs-350/pages.png alt="pages table"></p><h3 id=mmus>MMUs
<span><a href=#mmus><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Memory Management Units</p><h3 id=hardware-managed-mmu>Hardware Managed MMU
<span><a href=#hardware-managed-mmu><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Hardware reloads TLB with pages from a page tables</li><li>Typically hardware page tables are Radix Trees</li><li>Requires complex hardware</li><li>Examples: x86, ARM64, IBM POWER9+</li></ul><h4 id=intel-x86-paging>Intel x86 Paging
<span><a href=#intel-x86-paging><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Control registers are priviledged</li><li>bits in a control register (%cr0)</li><li>4KB pages</li><li>%c43 points to 4KB page directory</li><li>1024 page directory entries<ul><li>physical address of a page table</li></ul></li><li>page table has 1024 entries<ul><li>virtual 4K page per entry</li></ul></li></ul><h3 id=tlb>TLB
<span><a href=#tlb><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>x86 CPUs started using translation lookaside buffer (TLB) in caches to speedup page table lookup to avoid 3 memory references per load/store (page directory, page table, physical page access).</li><li>requires flushing on context switch to avoid returning invalid page</li><li>now each entry has a process ID to avoid flushing</li></ul><h3 id=os>OS
<span><a href=#os><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>OS lives in same address space of process</li><li>Permission bits</li><li>Map kernel in boot loader</li></ul><h3 id=software-managed-mmu>Software Managed MMU
<span><a href=#software-managed-mmu><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Simpler hardware and asks software to reload pages</li><li>Requires fast exception handling and optimized software</li><li>Enables more flexibility in the TLB (e.g. variable page sizes)</li><li>TLB fields: Virtual page, Pid, Page frame, NC (no cache), D[irty], V(alid), Global (ignore PID)</li><li>64 64-bit entries</li></ul><p>TLB Instructions</p><ul><li>twlbwr: write a random slot</li><li>tlbwi: write a specific slot</li><li>tlbr: read a specific slot</li><li>tlbp: probe a slot containing an address</li></ul><p>Registers needed to be loaded</p><ul><li>c0_entryhi: high bits of TLB entry</li><li>c0_entrylo: low bits of TLB entry</li><li>c0_index: TLB Index</li></ul><h4 id=tlb-exceptions>TLB Exceptions
<span><a href=#tlb-exceptions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>UTLB Miss: Generated when the accessing useg without matching TLB entry</li><li>TLB Miss: Generated when the accessing kseg2 without matching entry</li><li>TLB Mod: Generated when writing to read-only page</li></ul><h2 id=virtual-memory-os>Virtual Memory OS
<span><a href=#virtual-memory-os><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><h3 id=increasing-virtual-memory-by-paging>Increasing Virtual Memory by Paging
<span><a href=#increasing-virtual-memory-by-paging><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>The number of pages for a memory system is the size of the memory divided by the size of each page.</p><p>To translate a virtual address to a physical address, we replace the starting bits of the virtual address that corresponds to the
virtual page number, and replace it with the frame number.</p><ul><li>Use disk to simulate larger virtual than physical mem</li><li>Disk is much slower than memory so find 20% hot to put into memory and 80% cold into disk</li><li>How to resume after a page fault</li></ul><p>Restarting Instructions</p><ul><li>Faulting virtual address (In %c0_vaddr reg on MIPS)</li><li>Address of instruction that caused fault (%c0_epc reg)</li><li>Read or write, fetch, user access or kernel access?</li><li>Hardware must allow resuming after a fault</li><li>Idempotent instructions are easy<ul><li>A simple load or store instruction can be re-executed</li></ul></li></ul><p>Superpages</p><ul><li>Large mappings</li><li>2/4 MB mappings</li><li>Sometimes more pages in L2 cache than TLB entries</li></ul><h4 id=fifo-eviction>FIFO Eviction
<span><a href=#fifo-eviction><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Evict oldest fetched page in system</li></ul><h4 id=lru-page-replacement>LRU Page replacement
<span><a href=#lru-page-replacement><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Worse for looping over memory (better to use MRU eviction then)</li><li>Stamping timer is too expensive as it doubles memory traffic</li><li>Keeping a doubly-linked list is annoying</li><li>Better to approximate</li></ul><h4 id=clock-algorithm>Clock Algorithm
<span><a href=#clock-algorithm><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Do FIFO but skip accessed pages</li><li>Keep pages in circular FIFO list</li><li>Scan all and find a page that isn&rsquo;t set and Evict<ul><li>If A = 1, set A = 0. If A = 0, evict</li></ul></li><li>Runs when there is very low memory</li><li>When there is larger memory, use two clock hands at a fixed size. The first hands clears and the second hand picks evicted pages</li><li>Can take advantage of hardware dirty bit to prefer clean pages over dirty page. A dirty page has to be written to the disk</li></ul><p>Or use n-bit accessed count instead of just A bit. On sweep, count = (A &#171; (n - 1) | (count &#187; 1)). Evict the page with the lowest count.</p><p>Random eviction avoids belady and double swaps by hypervisors, and is simple to implement.</p><p>Databases are workload specific.</p><h4 id=other-page-replacement-algorithms>Other Page Replacement Algorithms
<span><a href=#other-page-replacement-algorithms><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Random eviction<ul><li>Used in hypervisors to avoid double swap</li></ul></li><li>LFU</li><li>MFU</li><li>Specific policies</li><li>Nave paging: 2 disk I/Os per fault</li></ul><h3 id=page-buffering>Page Buffering
<span><a href=#page-buffering><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Keep pool of free page frames. On fault, evict victim page, and read into free page so that execution can continue while writing out evicted page which is then added to the page pool.</p><h3 id=page-allocation>Page Allocation
<span><a href=#page-allocation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><h3 id=thrashing>Thrashing
<span><a href=#thrashing><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Threashing is when an application is in a constantly swapping pages in and out preventing the application from making forward progress at any reasonable rate.</p><p>Process uses more memory than system has</p><ul><li>working set<ul><li>How much cache/memory for process is required</li><li>Only run processes that meet requirements</li></ul></li><li>page fault frequency<ul><li>PFF = page faults / instructions executed</li><li>PFF > threshold = more memory? Swap out if no more memory</li><li>PFF &lt; threshdold = take away memory</li></ul></li></ul><h2 id=scheduling>Scheduling
<span><a href=#scheduling><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><h3 id=cpu-scheduling>CPU Scheduling
<span><a href=#cpu-scheduling><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Transition States</p><ul><li>new &ndash; admit &ndash;> ready &ndash; scheduler dispatch &ndash;> running &ndash; exit &ndash; I/O or event wait &ndash;> waiting</li><li>running &ndash; exit &ndash;> Terminated</li><li>waiting &ndash; I/O or event completion &ndash;> ready</li></ul><h4 id=scheduling-decisions>Scheduling Decisions
<span><a href=#scheduling-decisions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ol><li>Switches from running to waiting state</li><li>Switches from running to ready state</li><li>Switches from new/waiting to ready</li><li>Exits</li></ol><ul><li>Non-preemptive schedules use 1 & 4 only</li><li>Preemptive schedulers run at all four points</li></ul><h3 id=first-come-first-served>First Come First Served
<span><a href=#first-come-first-served><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>If P1 = 24, P2 = 3, P3 = 3,</p><ul><li><strong>Throughput</strong> = jobs / total time = 3 / 30 = 0.1 jobs / sec.</li><li><strong>Turnaround time</strong> = sum of end times / jobs = (24 + 27 + 30) / 3 = 27</li><li>long periods where no I/O is issued and CPU held</li><li>poor I/O device utilization</li></ul><h3 id=bursts-of-computation-and-io>Bursts of Computation and I/O
<span><a href=#bursts-of-computation-and-io><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Jobs are both compute and I/O waiting. Therefore overlap I/O and compute from multiple jobs.</p><h3 id=shortest-job-first>Shortest Job First
<span><a href=#shortest-job-first><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Schedule the job whose next CPU burst is the shortest</li><li>Attempts to minimize turnaround time<ul><li>Ends up <strong>minimizing waiting time</strong> and <strong>response time</strong></li></ul></li><li>With preemption, it is called shortest-remaining-time-first<ul><li>preemption means if a new job that has shorter CPU burst length, replace the job</li></ul></li><li>Requires estimating burst time because future cannot be predicted<ul><li>Exponentially weighted average</li><li>T<sub>n+1</sub> = alpha * t<sub>n</sub> + (1 - alpha) * T<sub>n</sub></li></ul></li><li>Can lead to unfairness and starvation</li></ul><h3 id=round-robin>Round Robin
<span><a href=#round-robin><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Preempts job after some time (quantum) and move it to the back of a FIFO</li><li>Disadvantages<ul><li>Context switching<ul><li>Saving and restoring registers</li><li>Switching address spaces</li><li>Cache, buffer cache, & TLB misses</li></ul></li><li>Slower than FCFS</li></ul></li></ul><h3 id=time-quantum>Time Quantum
<span><a href=#time-quantum><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>10-100msec</li><li>want larger than context switch cost so that context switching isn&rsquo;t completely suboptimal</li><li>majority of bursts should be less than quantum, otherwise way too much switching</li><li>not too large that it&rsquo;s basically FCFS</li></ul><h3 id=priority-scheduling>Priority Scheduling
<span><a href=#priority-scheduling><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Give a CPU to the process with highest priority</li><li>SJF is priority but using CPU burst time</li><li>Starvation - low priority processes may never execute</li><li>Increase a processors priority as it waits</li></ul><h3 id=multilevel-feedback-queue>Multilevel Feedback Queue
<span><a href=#multilevel-feedback-queue><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Priorities of 0 to 127 and grouped into 32 run queues</li><li>With each queue, run round robin</li><li>Favour interactive jobs</li><li>Run highest priority non-empty queue</li></ul><h4 id=process-priority>Process Priority
<span><a href=#process-priority><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li><em>p<sub>nice</sub></em>: user-settable weighting factor</li><li><em>p<sub>estcpu</sub></em>: per-process CPU usage<ul><li>Incremented whenever timer interrupt found proc. running</li><li>Decayed every second while process runnable
<img class=equation-tall src="https://latex.codecogs.com/svg.image?p_{estcpu}=\frac{2\times load}{2 \times load + 1}\times p_{estcpu} + p_{nice}"></li><li>Load is sampled average of length of run queue plus short-term sleep queue over last minute</li></ul></li><li>Run queue determined by <em>p<sub>usrpri</sub></em> / 4
<img class=equation-tall src="https://latex.codecogs.com/svg.image?p_{usrpri}=50 + \frac{p_{estcpu}}{4} + 2 \times p_{nice}\leq127"></li><li>For sleeping threads, update <em>p<sub>estcpu</sub></em> when runnable using <em>p<sub>slptime</sub></em> to avoid unnecessary computes:</li></ul><img class=equation-tall src="https://latex.codecogs.com/svg.image?p_{estcpu}=\frac{2\times load}{2 \times load + 1}^{p_{slptime}}\times p_{estcpu}"><h3 id=priority-donation>Priority Donation
<span><a href=#priority-donation><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>If lower priotity has a lock that medium priority wants, then the lower priority has the same priority as the medium.</p><p>If H waits on a lock held by M, then the priotity of M and L both go up, whereas if H waits on just the lock held by L, only L gets a priority bump to H.</p><h3 id=borrowed-virtual-time-scheduler>Borrowed Virtual Time Scheduler
<span><a href=#borrowed-virtual-time-scheduler><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Run process with lowest effective virtual time (E)</li><li>Use weights to get each processes fraction of CPU (seconds per virtual time tick while process has CPU)</li><li>track actual virtual time A<sub>i</sub> += t / w<sub>i</sub></li><li>E<sub>i</sub> = A<sub>i</sub> - (warp<sub>i</sub> ? W<sub>i</sub> : 0)<ul><li>W<sub>i</sub> is warp factor (thread precedence)</li></ul></li><li>Run j if E<sub>j</sub> &lt;= E<sub>i</sub> - C / w<sub>i</sub><ul><li>C is the context switch cost</li><li>Ignore context switch if j has just become runnable to avoid affecting response time</li></ul></li></ul><p>BVT example</p><p><img src=/images/cs-350/bvt-example.png alt="BVT example"></p><h3 id=sleep--wakeup>Sleep / Wakeup
<span><a href=#sleep--wakeup><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Increase actual time after wakeup (decreases priority)<ul><li>Otherwise starvation could occur on wakeup</li></ul></li><li>Scheduler Virtual Time (SVT) is the minimum A for all runnable threads</li><li>When waking up a process, set A to max{A_<sub>i</sub>, SVT}</li><li>Set A when voluntary sleep and not OS&rsquo;s doing (network ping is not OS&rsquo;s doing)</li><li>Processes won&rsquo;t get more than their fair share by using this method</li></ul><h3 id=real-time-threads>Real-time Threads
<span><a href=#real-time-threads><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Some tasks like watching videos, should always be respected when they need CPU, so that&rsquo;s why a Warp factor exists as shown before</li><li>When process i has warp enabled, then as long as it doesn&rsquo;t hold CPU for too long (L<sub>i</sub>), it&rsquo;s priority for the CPU is boosted when it needs to</li></ul><h2 id=io>I/O
<span><a href=#io><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p>Realistic PC Architecture</p><p><img src=/images/cs-350/pc-architecture.png alt="realistic older PC architecture"></p><p>I/O Bus PCI Example. Peripheral Component Interconnect Express (PCIe).</p><p><img src=/images/cs-350/pci-io-bus.png alt="PCI I/O bus example"></p><h3 id=memory-and-io-buses>Memory and I/O buses
<span><a href=#memory-and-io-buses><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>CPU has a bus to the Memory</li><li>Devices have an I/O bus to the Memory</li><li>Devices can appear to be Memory</li></ul><h3 id=memory-types>Memory Types
<span><a href=#memory-types><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>RAM stands for Random Access Memory.</p><ul><li>Static RAM (SRAM)<ul><li>4-6 transistors per bit</li><li>very fast, cache slower memory</li><li>two NOT gates</li></ul></li><li>Dynamic RAM (DRAM)<ul><li>1 transistor per bit</li><li>Capacitor + gate (charge indicates value)</li><li>Slower comparator since charge leaks</li><li>Re-write charge after reading</li></ul></li><li>Video RAM (VRAM)<ul><li>Write and read at the same time (dual ported)</li></ul></li></ul><h3 id=device-communication>Device Communication
<span><a href=#device-communication><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Memory-mapped devices<ul><li>Physical addresses correspond to device registers</li><li>load/store to get status/send instructions</li><li>2<sup>16</sup> port numbers</li><li>per-range access control not useful</li><li>OS has to map physical to virtual without caching</li><li>physical address assigned at boot</li></ul></li><li>Device memory<ul><li>OS can write to the device through I/O bus</li></ul></li><li>Special I/O Instruction<ul><li>Some CPUs have special I/O instructions</li><li>OS can allow user with finer granuality than a page</li></ul></li><li>DMA (direct memory access)<ul><li>Overlaps unrelated computation with moving data over I/O bus</li><li>Typically then need to poke card by writing to device register</li><li>Keep list of buffer locatioons in memory</li><li>use the CPU only to transfer control, not for data transfer</li><li>Network Interface Card (NIC)<ul><li>Bus interface logic uses memory to move packets to and from buffers in main memory</li></ul></li><li>Steps<ol><li>Tell device driver to transfer data to buffer at address X</li><li>Driver tells device controller to transfer bytes to buffer X</li><li>DMA transfer initiated for bytes C until C = 0; memory address increases and C decreases</li><li>DMA interrupts CPU to signal completion</li></ol></li></ul></li></ul><h3 id=driver-architecture>Driver Architecture
<span><a href=#driver-architecture><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Entry points provided to kernel: Reset, ioctl, output, interrupt, read, write, strategy</li><li>Need to synchronise<ul><li>Polling sucks because either CPU is blocked or high latency</li><li>Card should interrupt CPU<ul><li>CPU asks card what occured</li><li>High network packet arrival rate can prevent progress = mix of both</li></ul></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6ab825;font-weight:700>void</span> <span style=color:#447fcf>sendbyte</span>(<span style=color:#6ab825;font-weight:700>uint8_t</span> byte) {
</span></span><span style=display:flex><span>  <span style=color:#999;font-style:italic>/* Wait until BSY bit is 1. */</span>
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>while</span> ((<span style=color:#447fcf>inb</span> (<span style=color:#3677a9>0x379</span>) &amp; <span style=color:#3677a9>0x80</span>) == <span style=color:#3677a9>0</span>) <span style=color:#447fcf>delay</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#999;font-style:italic>/* Put the byte we wish to send on pins D7-0. */</span>
</span></span><span style=display:flex><span>  <span style=color:#447fcf>outb</span>(<span style=color:#3677a9>0x378</span>, byte);
</span></span><span style=display:flex><span>  <span style=color:#999;font-style:italic>/* Pulse STR (strobe) line to inform the printer
</span></span></span><span style=display:flex><span><span style=color:#999;font-style:italic>  * that a byte is available */</span>
</span></span><span style=display:flex><span>  <span style=color:#6ab825;font-weight:700>uint8_t</span> ctrlval = <span style=color:#447fcf>inb</span>(<span style=color:#3677a9>0x37a</span>);
</span></span><span style=display:flex><span>  <span style=color:#447fcf>outb</span>(<span style=color:#3677a9>0x37a</span>, ctrlval | <span style=color:#3677a9>0x01</span>);
</span></span><span style=display:flex><span>  <span style=color:#447fcf>delay</span>();
</span></span><span style=display:flex><span>  <span style=color:#447fcf>outb</span>(<span style=color:#3677a9>0x37a</span>, ctrlval);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=disks-io-subtopic>Disks (I/O Subtopic)
<span><a href=#disks-io-subtopic><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><ul><li>Stack of magnetic platters<ul><li>Each platter is divided into <a href=https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/WA_80_cm_archery_target.svg/1200px-WA_80_cm_archery_target.svg.png><em>concentric</em></a> tracks and each track has sectors</li><li>A stack of tracks with a fixed raidus is called a cylinder</li></ul></li><li>Disk arm assembly<ul><li>Arms rotate around pivot, all move together</li><li>Arms contain disk headsone for each cylinder</li><li>Heads read and write data to platters</li><li>One head active at a time</li></ul></li></ul><p><img src=/images/cs-350/disk-anatomy.png alt="disk anatomy"></p><h3 id=disk-positioning-system>Disk Positioning System
<span><a href=#disk-positioning-system><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Move head to specific track<ul><li>Keep it there by resisting physical shocks, imperfect tracks, etc.</li></ul></li><li>Seeking<ol><li>speedup - accelerate arm to max speed or hafl way point</li><li>coast - at max speed (for long seeks)</li><li>slowdown - stops arm near destination</li><li>settle - adjusts head to actual desired track</li></ol></li><li>Settle dominates very short seeks (~1ms)</li><li>Short seeks dominated by speedup (acceleration of 40Gs)</li></ul><h3 id=seeking>Seeking
<span><a href=#seeking><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Head adjustments</li><li>Settles take longer for writes because a checksum can be used to retry a read, but a write needs to be perfect otherwise another track got written to</li><li>Disk keeps table of pivot motor power<ul><li>Maps seek distance to power and time</li><li>Table set by periodic thermal recalibration<ul><li>Recalibration hurts audio-video</li></ul></li></ul></li><li>Average seek time can be anything from seeking a third of the disk to a third of the time required to seek entire disk</li></ul><h3 id=sectors>Sectors
<span><a href=#sectors><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Disk interface presents linear array of sectors</li><li>512 bytes written atomically</li><li>Disk handles mapping logical sector number to physical sector<ul><li>Zoning: puts more sectors on longer tracks</li><li>Track skewing: sector 0 pos. varies by track to speed up sequential access across tracks</li><li>Sparing: flawed sectors remapped elsewhere</li></ul></li><li>OS assumes disk is blackbox<ul><li>Larger logical sector # difference = larger seek</li><li>Can build table to estimate times through emperical tests</li></ul></li></ul><h3 id=disk-interface>Disk Interface
<span><a href=#disk-interface><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Controls hardware, mediates access</li><li>Connected to computer by bus that can be contended by multiple devices</li><li>Command queueing</li><li>Disk cache for read-ahead</li><li>Write caching is possible but unstable data</li></ul><h3 id=buses>Buses
<span><a href=#buses><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>SCSI<ul><li>Devices: host adapters & SCSI (bus) controllers</li><li>Service Delivery Subsystem connects devices (SCSI bus)</li></ul></li><li>SCSI-2 bus (SDS) connects up to 8 devices<ul><li>Controllers can have > 1 logical units (LUNs)</li><li>Controller built into disk</li><li>Bridge controller can manage multiple devices</li></ul></li><li>Device is either initiator or target<ul><li>Traditionally host adapter was initiator, controller the target</li><li>Controllers can be initiators</li><li>1 initiaor and at least one target</li></ul></li></ul><h3 id=scsi-requests>SCSI Requests
<span><a href=#scsi-requests><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>A request is a command from initiator to target</p><ul><li>Commmand<ul><li>Target gets control of bus but can disconnect and then reconnect</li><li>Task identifier: initiator ID, target ID, LUN, tag</li><li>Command descriptor block: read 10 blocks at pos. N</li><li>Task attribute: simple ordered, head of queue</li><li>Optional: output/input buffer, sense data</li><li>Status byte: good, check condition, intermediate</li></ul></li><li>Execution<ul><li>Each Logical unit maintains a queue of tasks { dormant, blocked, enabled, ended }</li><li>Simple tasks are dormant until no ordered/head of queue</li><li>Ordered tasks dormant until no HoQ/more recent ordered</li><li>HoQ tasks begin in enabled state</li></ul></li><li>Initatior can manage tasks<ul><li>Abort/terminate, reset</li></ul></li><li>Linked commands<ul><li>Atomic read-modify-write implementation</li><li>Intermediate commands return a status of intermediate</li></ul></li></ul><h3 id=scsi-exceptions>SCSI Exceptions
<span><a href=#scsi-exceptions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Stop executing most commands</li><li>Return &ldquo;check conditon&rdquo; status</li><li>Simple device implementation</li></ul><h3 id=disk-performance>Disk Performance
<span><a href=#disk-performance><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Ordering is huge issue</li><li>Sequential much faster than random</li><li>Power fail leads to inconsistent state</li><li>Order for crashes</li><li>Order requests to minimize seek times</li></ul><h3 id=disk-scheduling>Disk Scheduling
<span><a href=#disk-scheduling><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><h4 id=first-come-first-serve-fcfs>First Come First Serve (FCFS)
<span><a href=#first-come-first-serve-fcfs><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Process disk requests as they come in</li><li>Increases average latency</li><li>Cannot exploit request locality</li></ul><h4 id=shortest-positioning-time-first-sptf>Shortest Positioning Time First (SPTF)
<span><a href=#shortest-positioning-time-first-sptf><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Pick requests with shortest seek time</li><li>higher throughput and exploits locality</li><li>starvation (longer seeks never get a chance)</li><li>don&rsquo;t know which request will be fastest</li><li>Improve with aged SPTF<ul><li>Serve lowest priorities, adjust by wait time</li><li>T<sub>effective</sub>= T<sub>pos</sub> - W * T<sub>wait</sub></li></ul></li></ul><h4 id=elevator-scheduling-scan>Elevator Scheduling (SCAN)
<span><a href=#elevator-scheduling-scan><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Sweep across disk, servicing all requests passed</li><li>Seeks must be in the same direction</li><li>Switch directions if no further requests</li><li>Bounded waiting</li><li>Biased towards middle cylinders</li><li>Could miss an optimization SPTF would catch</li><li>CSCAN: only sweep in one direction (common in Unix)<ul><li>LOOK/CLOOK in textbook</li><li>After reaching disk end, jump to start of disk</li></ul></li></ul><h4 id=vscanr>VSCAN(r)
<span><a href=#vscanr><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>SPTF and SCAN</li><li>T<sub>effective</sub> = T<sub>pos</sub> + r * T<sub>max</sub></li><li>0 &lt;= r &lt;= 1</li><li>r determines how much same direction seeking is rewarded (0 = SPTF, 1 = SCAN)</li></ul><h3 id=flash-memory>Flash Memory
<span><a href=#flash-memory><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Solid state</li><li>Stores charge<ul><li>Charge wears off (Phone off for a year will cause data loss)</li></ul></li><li>Better heat and power consumption</li><li>Limited overwrites</li><li>Flash Translation Layer to protect physical block = performance impact</li><li>Random write are expensive</li></ul><h4 id=nor-flash>NOR flash
<span><a href=#nor-flash><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Can execute code in flash itself</li><li>Faster smaller unit reads</li><li>Slower erases</li></ul><h4 id=single-level-cell-slc-vs-multi-level-cell-mlc>Single-level cell (SLC) vs. Multi-level cell (MLC)
<span><a href=#single-level-cell-slc-vs-multi-level-cell-mlc><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>MLC encodes multiple bits in voltage level</li><li>MLC slower to write than SLC</li><li>MLC is basically more dense at write latency cost</li></ul><h4 id=nand-flash>NAND flash
<span><a href=#nand-flash><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Higher density</li><li>Faster erase/write</li><li>More errors needing error correction</li><li>2112-byte pages</li><li>Blocks contain 64 (SLC) or 128 (MLC) pages</li><li>Blocks divided into 2-4 planes<ul><li>All planes contend for same package pins</li><li>Block access in parallel</li></ul></li><li>Limited to reading one page at at ime<ul><li>25 micro seconds</li></ul></li><li>Must erase whole block before programming<ul><li>2ms</li></ul></li></ul><h2 id=filesystem>Filesystem
<span><a href=#filesystem><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><h3 id=files-name-bytes-on-disk>Files: name bytes on disk
<span><a href=#files-name-bytes-on-disk><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>File system: translate name & offset to disk blocks</li><li>Want to reduce number of disk accesses for operations (group related things)</li><li>File system metadata<ul><li>An inonde that points to the inode array.</li></ul></li></ul><h3 id=mappings>Mappings
<span><a href=#mappings><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>File metadata (inode): map byte offset to disk block address</li><li>Directory: map name to disk address or file #</li></ul><h3 id=intuitions>Intuitions
<span><a href=#intuitions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>perfomance related to disk accesses</li><li>each disk access takes time because of the rotataional delay</li></ul><h3 id=common-patterns>Common Patterns
<span><a href=#common-patterns><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Sequential<ul><li>Processed in sequential order</li></ul></li><li>Random access<ul><li>Access any block in a file without passing predecessors (skipping)</li></ul></li><li>Keyed access<ul><li>Search for block with particular values</li></ul></li></ul><h3 id=dos-fs>DOS FS
<span><a href=#dos-fs><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>File Allocation Table (FAT)</li><li>Each directory has a mapping of filenames to index in FAT</li><li>FAT contains next block.</li><li>FAT is small enough to be cached is cheaper than disk access.</li></ul><h3 id=indexed-files>Indexed files
<span><a href=#indexed-files><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>requires large chunks of contiguous space space</li><li>array of block pointers per file</li><li>free list for allocations</li></ul><h3 id=multi-level-indexed-files>Multi-level indexed files
<span><a href=#multi-level-indexed-files><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>14 block pointers</li><li>first couple pointer point to blocks</li><li>other pointers point to more and more indirect blocks</li></ul><h3 id=directories>Directories
<span><a href=#directories><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li><p>Approach 1: known disk location; {name, inumber}, unique names</p></li><li><p>Approach 2: Single directory per user</p></li><li><p>Approach 3: Hierarchical name spaces, graph</p></li><li><p>Root directory is always inode 2</p></li><li><p>Special names in FS: (Root: &ldquo;/&rdquo;), (Current: &ldquo;.&rdquo;), (Parent: &ldquo;..&rdquo;)</p></li><li><p>Special names not in FS: (User dir: &ldquo;~&rdquo;), globbing</p></li><li><p>Use cd to change directory, and ls to list names in current directory</p></li></ul><h3 id=hard-and-soft-links>Hard and soft links
<span><a href=#hard-and-soft-links><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Each inode has a count of hard links</li><li>Use <code>ln source synonym</code> to create a link</li><li>Inode for has special symlink bit set and contains target name (automatically translated by file system)</li></ul><h3 id=fast-file-system-ffs>Fast File System (FFS)
<span><a href=#fast-file-system-ffs><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><ul><li>Original file system<ul><li>was slow and required inodes for directories as well</li><li>blocks too smal (512 bytes)</li><li>index too large</li><li>poor clustering of related blobs, inodes far from datablocks, poor enumeration</li><li>lacked atomic file updating</li><li>uses a free list (linked list) of free blocks which gets jumbled and slow to find adjacent blocks</li></ul></li><li>Cluster related objects together and seperate unrealted items</li><li>With bigger block sizes, split unused large portions into <em>fragments</em> when there is a need to allocate smaller files</li><li>Fixed-size fragments allows the file system to allocate files in a more organized manner, which reduces fragmentation and improve performance</li><li>Uses bit-map of free blocks which is much easier to find contiguous blocks and can be stored in memory, time increases only when fewer free blocks</li></ul><h4 id=clustering-in-ffs-using-cylinder-groups>Clustering in FFS Using Cylinder Groups
<span><a href=#clustering-in-ffs-using-cylinder-groups><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Group at least one consequtive cylinder into a <em>cylinder group</em></li><li>Order of retrieval is can access any block in a cylinder without a seek, and the next fastest place is an adjacent cylinder</li><li>Put related data in the same cylinder group and unrealted items in another group<ul><li>Different directories are placed in different cylinder groups</li></ul></li><li>Tries to put sequential blocks in adjacent sectors</li><li>Tries to keep same inode in same cylinder as file data</li><li>Tries to keep all inodes for a dir in the same cylinder group</li><li>Each cylinder group is a mini-Unix file system with a starting super block</li></ul><h4 id=bitmap>Bitmap
<span><a href=#bitmap><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><p>As said before, a bitmap is used in place of a free list to make it much simpler to find contiguous free blocks. It can also be stored in memory as it is small.</p><ul><li>If a 4GB disk has 4KB blocks, how big is the map? Each bit represents a 4KB blocks, so 4,000,000 KB / 4,000 KB = 1,000 bits = 125 bytes</li><li>Keep 10% reserved without informing user</li><li>Only allow root to allocate from the 10%</li></ul><h4 id=ffs-next-steps>FFS Next Steps
<span><a href=#ffs-next-steps><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h4><ul><li>Contiguous blocks are named with a single pointer and length (ext2fs)</li><li>Writes were done synchronously</li><li>Make writes async with write-ordering or logging/journaling</li></ul><h3 id=log-structured-file-system>Log-Structured File System
<span><a href=#log-structured-file-system><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p><a href=https://web.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf>paper</a></p><h3 id=metadata-synchronously>Metadata Synchronously
<span><a href=#metadata-synchronously><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>If we create a directory entry and crash during the middle of creating a directory entry and an IO block, what happens?</p><ul><li>Block on disk</li><li>Inode</li><li>Directory entry pointing to an inode</li></ul><p>To ensure things work correctly, we need to flush to disk before the pointer pointing to the inode gets flushed. Therefore, we need to write out the data first, then create the inode, and then create the directory entry pointing to it. When deleting, first delete the directory entry, and then the inode.</p><p>Log inode and dir entry to a log first. On crash, re-execute the log to copy back the file system. This is 2x the IO writes.
1GB sized journals.</p><h2 id=the-slab-allocator>The Slab Allocator
<span><a href=#the-slab-allocator><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p><a href=https://rcs.uwaterloo.ca/~ali/readings/bonwick.pdf>bonwick.pdf</a></p><h3 id=object-caching>Object Caching
<span><a href=#object-caching><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Allocating an object and destroying it repeatedly is time consuming and wasteful and can be improved upon by using a cache. Use a cached object if it in the cache and upon freeing, return the object to the cache. Better to do this in the central allocator since the OS has more insight into overall memory usage and it avoids bloating the size of the kernel code.</p><h3 id=questions>Questions
<span><a href=#questions><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h3><p>Question 1 (4)</p><p>How does the slab allocator improve the worst-case runtime?</p><p>In the worst case, there are lots of objects that are big in size.
Objects are cached in the slab allocator meaning that repeatedly allocating and freeing objects will not result in wasteful constructions and destructions. Rather with the cache, the object is simply initialized just once and is retrieved from the cache or put back into the cache. The client can also decide when to create and destroy the cache itself for many objects.</p><p>Secondly, this object caching mechanism allows the slab allocator to take up pages for the same object type and use reference counting to free these pages rather than complex data structures that are non-constant in runtime. Therefore, allocations and reclaiming memory is fast as well. When objects are of the same time, they have the same lifetime distribution meaning less chance of pages being held meaning faster memory allocations when there are many applications running and competing for memory.</p><p>Question 2 (4)</p><p>How does the slab allocator improve the best-case runtime?</p><p>In the best case, there are only allocations of small objects at the beginning and frees at the end. The slab layout offers a stub at the end of each slab for containing information about the buffers it has available. The interfaces are extremely lightweight meaning that little memory allocations.</p><p>The slab allocator improves the best-case runtime, because as written in 5.3 (2), cache utilization is better. The Slab allocator gives each slab an offset so that buffers are distributed evenly throughout the cache rather than heavily loading the same cache lines. Without the offset, the same lines of the cache would be read since each buffer is of the same object type. The offset alleviates this cache loading and thus improves the miss rate which thus improve runtime even in the best cases.</p><p>Question 3 (3)</p><p>List the three largest sources of improved OS performance when using a slab allocator?</p><ul><li>Object-cache interface</li><li>Memory management via slabs (no limits, faster counting, same type buffers to reduce fragmentation)</li><li>Slab coloring to improve cache utilization</li></ul><h2 id=the-fast-file-system>The Fast File System
<span><a href=#the-fast-file-system><svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg></a></span></h2><p><a href=https://rcs.uwaterloo.ca/~ali/readings/ffs.pdf>ffs.pdf</a></p><p>512 bytes -> 1024 resulted in 2x performance</p><ul><li>each disk transfer accessed twice the amount of data</li><li>direct blocks contained twice as much data -> most files dont need indirect blocks
Randomization of data blocks causes deteriorated performance due to seeking before access
Super-block is at the start of each partition and contains critical data and is replicated.</li></ul><p>Question 1 (4)</p><p>How does the performance benefits of cylinder groups change with number of cylinder groups? How would you size the cylinder groups on a modern multi-terabyte disk?</p><p>The more cylinder groups, the more times the OS can group related data together. This means that bigger files can be stored and be read more efficiently (single pass). For sizing the cylinder groups on a multi-terabyte disk, we can expect files that are many gigabytes in size and so need enough groups to distribute these big files across many groups. We need 10MB cylinder groups to allocate a 100GB file on a 1TB system (1TB / 100GB ~= 10 MB). Reasoning is The heuristic solution chosen is to redirect block allocation to a different cylinder group when a file exceeds 48 kilobytes, and at every megabyte thereafter.</p><p>Question 2 (4)</p><p>One can repair most POSIX file systems through the fsck command. Typically, the computer detects an unclean unmount through the superblock and repairs the file system before the computer starts up by running fsck. If we want to optimize the computer startup time, we need to run fsck in the background and the file system must be &lsquo;correct enough&rsquo; to allow the computer to operate on it. Describe at least one precondition all file system writes must adhere to, to allow one to repair the file system in the background after the computer has booted.</p><p>Writes must not corrupt the filesystem. For writes to not corrupt the filesystem, at all times, all inodes must point to valid data, and all directory entries must point to valid inodes. Therefore, writes must be done in the order of disk, then inode creation, then directory entry. This ensures that corrupt or random garbage data is not being read or pointed to by a directory entry or inode. This way, fsck can fix any broken pointers in the background while the computer boots fine.</p><p>Quesion 3 (2)</p><p>If you don&rsquo;t want to use fragments, how can you reduce the space wasted by very small files (i.e., less than 56 Bytes).</p><p>Dedicate end portions of each cylinder group for very small files. So blocks of 56 at the very of end of each group. Then whenever a file needs to be read or written, the OS should try reading from the end of the group rather than the front. Prevent bigger files from writing into these blocks. Since each cylinder group will have a fixed size, the OS should be able to calculate which blocks are of size 4096 and which blocks are of a smaller size, and then prevent writing multiple smaller blocks unless necessary. In essence, dedicated blocks for very small files at the end of each cylinder group where the OS knows beforehand the change in block sizes will enable reducing wasted space without using fragments.</p></div><div class=post-info><div class="post-date dt-published">2023-Jan-10</div><a class="post-hidden-url u-url" href=https://blog.elijahlopez.ca/posts/cs-350-operating-systems/>https://blog.elijahlopez.ca/posts/cs-350-operating-systems/</a>
<a href=https://blog.elijahlopez.ca/ class="p-name p-author post-hidden-author h-card" rel=me>Elijah Lopez</a><div class=post-taxonomies><ul class=post-tags><li><a href=https://blog.elijahlopez.ca/tags/university/>#university</a></li></ul></div></div></article><div class="pagination post-pagination"><div class="left pagination-item"><a href=/posts/cs-348-intro-to-database-management/>CS 348 Intro to Database Management</a></div><div class="right pagination-item"><a href=/posts/tauri-custom-titlebar/>Tauri Custom Titlebar (React)</a></div></div><script src=https://utteranc.es/client.js repo=elibroftw/blog.elijahlopez.ca theme=github-dark label issue-term=url crossorigin=anonymous async></script></main><footer class=common-footer><div class=common-footer-bottom><div class=copyright><p> Elijah Lopez, 2023<br>Powered by <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, theme <a target=_blank rel="noopener noreferrer" href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.<br></p></div><script>const STORAGE_KEY="user-color-scheme",defaultTheme="dark-without-switcher";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeButtonText()};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme=="dark"&&document.documentElement.setAttribute("data-theme","dark"),currentTheme=="auto"&&(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)),switchButton&&(changeButtonText(),switchButton.addEventListener("click",switchTheme,!1)),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":"light"}function changeButtonText(){switchButton&&(switchButton.textContent=currentTheme=="dark"?"Light theme":"Dark theme")}function switchTheme(){currentTheme=="dark"?(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"light"),document.documentElement.setAttribute("data-theme","light"),currentTheme="light"):(localStorage!==null&&localStorage.setItem(STORAGE_KEY,"dark"),document.documentElement.setAttribute("data-theme","dark"),currentTheme="dark"),changeButtonText()}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}</script></div><p class="h-card vcard"><a href=https://blog.elijahlopez.ca/ class="p-name u-url url fn" rel=me>Elijah Lopez</a>
/
<a class="p-email u-email email" rel=me href=mailto:elijahllopezz@gmail.com>elijahllopezz@gmail.com</a>
<img class=u-photo src=/images/me.png></p></footer></div></body></html>